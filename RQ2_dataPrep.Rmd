---
title: "RQ2_dataPrep"
author: "Kamau Lindhardt, lbk125"
date: "5/15/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Research Question 2

2. How are the (major and minor) themes of temperate silvoarable agroforestry systems distributed across geographical, bioclimatic and socio-economic gradients?

a.	How does the system properties temperature and precipitation drive inter-site differences?
b.	How does the system properties soil type and soil quality drive inter-site differences?
c.	Does European marginalised rural area classes drive inter-site differences?


Packages to be installed first
```{r Installing the pacman package, warning=FALSE}
# install.packages("pacman")
# install.packages("tidygeocoder")
# install.packages("ggdensity")
# install.packages("rnaturalearth")
# install.packages("rnaturalearthdata")
# install.packages("gridExtra")
# install.packages("soilDB")
# install.packages("aqp")
# install.packages("geodata")
```

Loading packages and libraries
```{r Loading other needed packages, warning=FALSE}
suppressWarnings({ 

# Applying the p_load function to load multiple add-on packages in one line of code.
  
pacman::p_load(tidyverse, 
               corrplot,
               ggarrange,
               gridExtra,
               tidygeocoder,       # for making geospatial analysis (e.g. derive coordinates from location names)
               rnaturalearth,      # facilitates world mapping by making Natural Earth map data more easily available 
               rnaturalearthdata,  # holds data used by rnaturalearth package from Natural Earth.
               
               readr,
               vroom,       # for crazy fast method of loading/reading datasets from local disc
               readxl,
               ggplot2,
               ggdensity,
               
               raster,      # for general spatial analysis and in particular for downloading BioClim variables from WorldClim
               #geodata     # use geodata::worldclim_global() instead of raster::getData() if encounting issues
               sp,
               sf,
               
               soilDB,      # for downloading predicted soil properties from ISRIC SoilGrids
               aqp)        

  })
```


Loading main database 
```{r Loading database 2.0, warning=FALSE, message=FALSE}
suppressWarnings({ 
  
database.geospatial <- read_excel("DATA/DATABASE_2.0.xlsx", 
    sheet = "MAIN_DATABASE_2.0") %>%
    filter(INCLUDED == TRUE)

})
# View(database)
```


**Deriving latitude and longitude of study site locations** - *be aware: this piece of code takes a while to run*
```{r Deriving latitude and longitude, warning=FALSE, message=FALSE, eval = FALSE}
# Notice this piece of code takes a ffew minutes, as hundreds of lat long coordinates has to be derived based on names in the STUDY.LOC.SPEC.COORDS column

database.lat.lon <- database.geospatial %>%
  tidygeocoder::geocode(STUDY.LOC.SPEC.COORDS, method = 'osm', lat = latitude , long = longitude) 

# Saving the dataset with derived coordinates unto local disc
readr::write_csv(database.lat.lon, "./DATASET.FROM.SCRIPT/database.lat.lon.csv")
```

Loading dataset with lat long coordinates from local disc
```{r Loading dataset with lat long coordinates}

database.lat.lon <- vroom::vroom("./DATASET.FROM.SCRIPT/database.lat.lon.csv") %>%
  filter(INCLUDED == TRUE) %>%
  
  mutate(`SAF System Trait type` = recode(ST.TYPE,                      # rename dataframe rows
                                          RBS = "Riparian buffer strips",
                                          SHB = "Line belts *",
                                          MIXED = "Mixed systems",
                                          TIMBER.ARABLE = "Timber - Arable",
                                          BIOMASS.ARABLE = "Biomass - Arable",
                                          NUT.ARABLE = "Nut - Arable",
                                          FRUIT.ARABLE = "Fruit - Arable",
                                          .keep = "all")) %>%
  
  dplyr::mutate(ST.TYPE.PROD.TYPE = "x") %>%
  mutate(ST.TYPE.PROD.TYPE = recode(ST.TYPE,                      # rename dataframe rows
                                    TIMBER.ARABLE = "Biomass",
                                    BIOMASS.ARABLE = "Biomass",
                                    NUT.ARABLE = "Food",
                                    FRUIT.ARABLE = "Food",
                                    RBS = "Multiple",
                                    SHB = "Multiple",
                                    MIXED = "Multiple",
                                    .keep = "all")) 
glimpse(database.lat.lon)
```

Defining number of independent studies and number of observations based on individual study sites
```{r Number of studies and study sites}
n_independent_studies <- database.lat.lon %>% 
  distinct(ID.P) %>%
  nrow()

# n_independent_studies = 73 (16 aug. 2022)

n_individual_study_sites <- database.lat.lon %>%
  distinct(ID.P, ID.S) %>%
  nrow()

# n_individual_study_sites = 213 (16 aug. 2022)
```

Re-locating the column names to get a better overview of lat long
```{r Re-locating the column names to get lat long}
database.lat.lon <-
  database.lat.lon %>%
  relocate(ID.P, ID.S, TITLE,
           latitude, longitude, STUDY.LOC.COUNTRY, STUDY.LOC.SPEC, STUDY.LOC.SPEC.COORDS)

# View(database.lat.lon) # <-  un-comment to see the database with lat long
```


*Listing study sites with missing value in the latitude column*
```{r Study sites with missing lat (long) values, eval=FALSE}
location.missing <- database.lat.lon %>%
  filter_all(any_vars(is.na(latitude))) %>%
  relocate(ID.P, ID.S, TITLE,
           latitude, longitude, STUDY.LOC.COUNTRY, STUDY.LOC.SPEC, STUDY.LOC.SPEC.COORDS)

# View(location.missing)

# Replacing the observations that have missing values in 'Location Specification' with the information from the general 'Location' column

# 28 studies had missing information for the latitude column (location missing). These were then manually checked and a nearby location was added where possible by re-visiting the papers and checking the study sites on Google Maps. The previous lines of code was run again, now with  zero (0) missing locations. 
```

### Preliminary explorative analysis

Visualising the locations on a map
```{r Quick plot of the locations on a map}
# using n_individual_study_sites because some studies include multiple sites with different system traits, species compositions and arrangements. 

database.lat.lon %>%
ggplot(aes(longitude, latitude), color = "grey99") +
  borders("world") + 
  geom_point(aes(color = ST.TYPE), size = 0.5, alpha = 0.8) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
  scale_fill_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Visualising peer-reviewed silvoarable paper' study site locations on a map",
       subtitle = paste("n (study sites) = ", n_individual_study_sites),
       x = "Longitude",                       
       y = "Latitude")
```


Most prevailing countries - where most studies (study sites) have been conducted
```{r Where most studies (study sites) have been conducted}
# using n_individual_study_sites because system traits vary between sites, as some studies include multiple sites with different species compositions and arrangements. 

database.lat.lon %>%
  count(STUDY.LOC.COUNTRY, sort = TRUE) 


# using n_independent_studies  

pub.country.geo <- 
  database.lat.lon %>% 
  dplyr::filter(INCLUDED == TRUE) %>%
  dplyr::select(ID.P, STUDY.LOC.COUNTRY) %>%
  distinct(ID.P,  STUDY.LOC.COUNTRY) %>%
  group_by(STUDY.LOC.COUNTRY) %>% 

  summarise(no_studies = n()) %>%
  dplyr::mutate_if(is.integer, as.numeric) %>%
  dplyr::filter(no_studies > 2) %>%
  arrange(desc(no_studies)) 
```



# RQ2: How are the (major and minor) themes of temperate silvoarable agroforestry systems distributed across geographical, bioclimatic and socio-economic gradients?


**Temperature and precipitation data from WorldClim (BioClim)**

*A little info about using WorldClim variables in spatial analysis in r*

BioClim variables available in WorldClim

Bioclimatic variables are derived from the monthly temperature and rainfall values in order to generate more biologically meaningful variables. These are often used in species distribution modelling and related ecological modelling techniques. The bioclimatic variables represent annual trends (e.g., mean annual temperature, annual precipitation) seasonality (e.g., annual range in temperature and precipitation) and extreme or limiting environmental factors (e.g., temperature of the coldest and warmest month, and precipitation of the wet and dry quarters). A quarter is a period of three months (1/4 of the year). (see more here: https://www.worldclim.org/data/bioclim.html)

Don't forget that WorldClim data has a scale factor of 10, so Temp = -37 is -3.7 ºC.

BIO1 = Annual Mean Temperature
BIO2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))
BIO3 = Isothermality (BIO2/BIO7) (×100)
BIO4 = Temperature Seasonality (standard deviation ×100)
BIO5 = Max Temperature of Warmest Month
BIO6 = Min Temperature of Coldest Month
BIO7 = Temperature Annual Range (BIO5-BIO6)
BIO8 = Mean Temperature of Wettest Quarter
BIO9 = Mean Temperature of Driest Quarter
BIO10 = Mean Temperature of Warmest Quarter
BIO11 = Mean Temperature of Coldest Quarter
BIO12 = Annual Precipitation
BIO13 = Precipitation of Wettest Month
BIO14 = Precipitation of Driest Month
BIO15 = Precipitation Seasonality (Coefficient of Variation)
BIO16 = Precipitation of Wettest Quarter
BIO17 = Precipitation of Driest Quarter
BIO18 = Precipitation of Warmest Quarter
BIO19 = Precipitation of Coldest Quarter

The WorldClim data are available at different spatial resolutions (expressed as minutes or seconds of a degree of longitude and latitude): 10 minutes, 5 minutes, 2.5 minutes, 30 seconds. The variables included are monthly minimum and maximum temperature, precipitation, and 'bioclimatic' variables. The original WorldClim data were at a 30 second resolution, the other data have been derived through aggregation, by calculating the mean of groups of cells. The 10-minute spatial resolution is about 18.6 x 18.6 = 344 km2 at the equator. Here we are going to use 2.5-minute spatial resolution (res=2.5), this is about 4.5 km at the equator according to WorldClim https://www.worldclim.org/data/v1.4/cmip5_2.5m.html

To get (projected) future climate data (CMIP5), you must provide arguments var and res as above. Only resolutions 2.5, 5, and 10 are currently available. In addition, you need to provide model, rcp and year. For example,
getData('CMIP5', var='tmin', res=10, rcp=85, model='AC', year=70)

Getting WorldClim data through r

If name = 'worldclim' you must also provide arguments var, and a resolution res. Valid variables names are 'tmin', 'tmax', 'prec' and 'bio'. Valid resolutions are 0.5, 2.5, 5, and 10 (minutes of a degree). In the case of res=0.5, you must also provide a lon and lat argument for a tile; for the lower resolutions global data will be downloaded. In all cases there are 12 (monthly) files for each variable except for 'bio' which contains 19 files.

- getData('worldclim', var='tmin', res=0.5, lon=5, lat=45)

- getData('worldclim', var='bio', res=10)

see also more information: https://worldclim.org/data/v1.4/formats.html and on the blog post of Emily Piche https://emilypiche.github.io/BIO381/raster.html and Peter Galante https://rsh249.github.io/spatial_bioinformatics/worldclim.html

*Extracting/downloading the bioclimatic variables needed: Temperature and precipitation*

Dataframe with coordinates 
```{r Creating the simple dataframe with coordinates}
# Make a dataframe with coordinates
study.site.coords <- database.lat.lon %>%
  relocate(ID.P, ID.S, TITLE,
           latitude, longitude, STUDY.LOC.COUNTRY, STUDY.LOC.SPEC, STUDY.LOC.SPEC.COORDS) %>%
  dplyr::select(longitude, latitude)

# latitude and longitude coordinate points converted to dataframe
latitude <- as.data.frame(study.site.coords[, 2])
longitude <- as.data.frame(study.site.coords[, 1])

# latitude and longitude coordinate points converted to vectors in order to work in the getData() function
latitude <- as.list(latitude)
longitude <- as.list(longitude)

# coordinates used for the getData() function
coords <- data.frame(x = longitude,
                     y = latitude)
```

Extracting/downloading BioClim variables using the getData() function from the raster package
```{r Extracting/downloading BioClim variables, warning=FALSE, message=FALSE, eval=FALSE}
# downloading bioclimatic variables from worldclim at a resolution of 2.5 minutes
# this is saved as a RasterStack object that contains all the 19 bioclim variables

# be aware of the warning ""getData will be removed in a future version of raster\n. Please use the geodata package instead"
# in the future the getData() function from raster might be depreciated. Instead use geodata::worldclim_global()
bioclim.rasterstack <- raster::getData("worldclim",     
                               var = "bio",
                               res = 2.5)

# specifying that we only need; temperature (BIO1 = Annual Mean Temperature) and precipitation (BIO12 = Annual Precipitation)
bioclim.temp.precip <- bioclim.rasterstack[[c(1,12)]]
names(bioclim.temp.precip) <- c("Temp","Prec")

# converting the data into a SpatialPoints dataframe by adding the same coordinate reference system
points <- SpatialPoints(coords, proj4string = bioclim.temp.precip@crs)

# extracting point-specific information on temperature and precipitation from the bioclim RasterStack object using the point coordinates
temp.precip.values <- raster::extract(x = bioclim.temp.precip, 
                                      y = points) %>%
  as.data.frame()


# Saving the temp.precip.values dataset with derived coordinates unto local disc
readr::write_csv(temp.precip.values, "./DATASET.FROM.SCRIPT/temp.precip.values.csv")
```


Loading BioClim dataset (temperature and precipitation) with lat long coordinates from local disc
```{r Loading dataset with lat long coordinates}

temp.precip.values <- vroom::vroom("./DATASET.FROM.SCRIPT/temp.precip.values.csv")
```

*Merging (joining) the location-specific temperature and precipitation values to the coordinates (x,y)*
```{r Joining location-specific bioclim info to the coordinates}
bioclim.point.data <- cbind.data.frame(coordinates(points), 
                       temp.precip.values)
```

*Merging (joining) bioclim values to the original database using the coordinates (x,y)*
```{r Joining location-specific bioclim info to the original database}
bioclim.point.data.tbl <- as_tibble(bioclim.point.data)

# ------------------------------------------------------------------------------------------------
database.coords.bioclim  <- 
  left_join(x = database.lat.lon, y = bioclim.point.data.tbl, 
            by = c("longitude" = "longitude",
                   "latitude" = "latitude"))  %>%
  mutate_at(c("ID.P", "ID.S"), as.numeric) %>%
  relocate(ID.P, ID.S, TITLE,
           STUDY.LOC.COUNTRY, STUDY.LOC.SPEC, STUDY.LOC.SPEC.COORDS,
           latitude, longitude, Temp, Prec)
# ------------------------------------------------------------------------------------------------
```



**Soil properties data from SoilGrids (ISRIC)**

*A little info about using SoilGrids variables in spatial analysis in r*

SoilGrids is a system for global digital soil mapping that uses state-of-the-art machine learning methods to map the spatial distribution of soil properties across the globe. SoilGrids prediction models are fitted using over 230 000 soil profile observations from the WoSIS database and a series of environmental covariates. Covariates were selected from a pool of over 400 environmental layers from Earth observation derived products and other environmental information including climate, land cover and terrain morphology. The outputs of SoilGrids are global soil property maps at six standard depth intervals (according to the GlobalSoilMap IUSS working group and its specifications) at a spatial resolution of 250 meters. Prediction uncertainty is quantified by the lower and upper limits of a 90% prediction interval. The additional uncertainty layer displayed at soilgrids.org is the ratio between the inter-quantile range and the median. The SoilGrids maps are publicly available under the CC-BY 4.0 License.

Maps of the following soil properties are available: pH, soil organic carbon content, bulk density, coarse fragments content, sand content, silt content, clay content, cation exchange capacity (CEC), total nitrogen as well as soil organic carbon density and soil organic carbon stock. SoilGrids predictions are made for the six standard depth intervals specified in the GlobalSoilMap IUSS working group and its specifications. The depth intervals returned are: "0-5cm", "5-15cm", "15-30cm", "30-60cm", "60-100cm", "100-200cm".

Find out more information about the SoilGrids and GlobalSoilMap products here: https://www.isric.org/explore/soilgrids/faq-soilgrids and check ISRIC's data policy, disclaimer and citation: https://www.isric.org/about/data-policy. and here: https://www.isric.org/sites/default/files/GlobalSoilMap_specifications_december_2015_2.pdf

The soilsDB package contains a collection of functions for reading data from various digital soil libraries and soil maps, including SoilGrids. Find more information about the soilsDB package here: https://ncss-tech.github.io/AQP/soilDB/soilDB-Intro.html

The fetchSoilGrids() function from soilDB obtains SoilGrids properties information (250 m raster resolution) given a data.frame containing site IDs, latitudes and longitudes. SoilGrids API and maps return values as whole (integer) numbers to minimize the storage space used. These values are converted by to produce conventional units by 'fetchSoilGrids()'

The soil properties from ISRIC SoilGrids returned by the fetchSoilGrids() function are: 

- bdod, Bulk density of the fine earth fraction; mapped unit: [cg/cm^3], conversion: 100, conventional factor unit:	[kg/dm^3]
- cec,	Cation Exchange Capacity of the soil. [mmol(c)/kg	10	cmol(c)/kg]
- cfvo, Volumetric fraction of coarse fragments (> 2 mm); mapped unit: [cm^3/dm^3 (vol per mil)], conversion: 10, conventional factor unit: [cm^3/100cm^3 (vol%)]
- clay, Proportion of clay particles (< 0.002 mm) in the fine earth fraction;	mapped unit: [g/kg], conversion:	10, conventional factor unit:	[g/100g (%)]
- nitrogen,	Total nitrogen (N); mapped unit:	[cg/kg], 	conversion: 100, conventional factor unit:	[g/kg]
- phh2o, Soil pH; mapped unit: [pH*10], conversion: 10, conventional factor unit: pH
- sand, Proportion of sand particles (> 0.05 mm) in the fine earth fraction; mapped unit: [g/kg], conversion:	10, conventional factor unit:	[g/100g (%)]
- silt, Proportion of silt particles (= 0.002 mm and = 0.05 mm) in the fine earth fraction; mapped unit:	[g/kg], conversion: 10, conventional factor unit: [g/100g (%)]
- soc, Soil organic carbon content in the fine earth fraction; mapped unit: [dg/kg], conversion: 10, conventional factor unit: [g/kg]
- ocd,	Organic carbon density;  mapped unit: [hg/m^3], conversion:	10, conventional factor unit: [kg/m^3]
- ocs,	Organic carbon stocks; mapped unit: [t/ha], conversion:	10, conventional factor unit:	[kg/m^2]

Read more about units and conversion factors of SoilGrids here: https://www.isric.org/explore/soilgrids/faq-soilgrids

*Extracting/downloading the soil variables from SoilGrids using the soilDB package*

Dataframe with coordinates and id
```{r Creating the study site location dataframe}
# creating simple dataframe that only contains id and location (lat., lon.)
database.locations.df <- 
  database.lat.lon %>% 
  dplyr::select(ID.P, ID.S,
         latitude, longitude) %>%
  dplyr::mutate_at(vars(ID.P, ID.S), as.numeric) %>%
  
  # conversing the ID.S + ID.P columns into only one "id" column by collapsing the two ID.S + ID.P columns
  rowwise() %>% 
  mutate(ID.PAIR = paste0(sort(c(ID.P, ID.S)), collapse = " ")) %>% 
  separate(ID.PAIR, " ", into = c("ID.P", "ID.S")) %>%
  mutate(ID = row_number()) %>%
  
  # renaming the lat. lon. columns and converting to dataframe
  dplyr::rename("lat" = latitude,
                "lon" = longitude,
                "id" = ID) %>%
  dplyr::mutate_at(vars(id), as.numeric) %>%
  dplyr::select(id, lat, lon) %>%
  as.data.frame()
```

Extracting/downloading soil variables from ISRIC SoilGrids using the fetchSoilGrids() function from the soilsDB package.
```{r Extracting/downloading SoilGrids soil variables, warning=FALSE, message=FALSE, eval=FALSE}
# be aware that this function call takes quite some time, this is also why results are saved to local disc
SoilGrids.data <- soilDB::fetchSoilGrids(x = database.locations.df,
                                         progress = TRUE) 

# not a dataframe: class(SoilGrids.data)

# Saving the downloaded SoilGrids dataset unto local disc
readr::write_rds(SoilGrids.data, "./DATASET.FROM.SCRIPT/SoilGrids.data.Rds")
```

Loading SoilGrids dataset from local disc
```{r Loading SoilGrids dataset}

SoilGrids.data <- readr::read_rds("./DATASET.FROM.SCRIPT/SoilGrids.data.Rds")
```

Generating dataframe with fetched soil variables 
```{r Dataframe with fetched soil variables}
# selecting only relevant variables
fetchedSoilGrid.df <- 
  aqp::horizons(SoilGrids.data) %>% 
  dplyr::select(id, label, claymean, sandmean, siltmean, bdodmean, nitrogenmean, socmean, phh2omean, cecmean) %>%
  # notice: we exclude NA values - these are empty values from locations located in urban areas where SoilGrids do not have info
  drop_na(claymean, sandmean, siltmean, bdodmean, nitrogenmean, socmean, phh2omean, cecmean) %>% 
  dplyr::mutate_at(vars(id), as.numeric) %>%
  dplyr::arrange(id)
```

*Merging (joining) the location-specific soil values to the coordinates (x,y - with lat. lon.)*
```{r Joining location-specific soil info to the original database}
# first, we merge the SoilGrids soil data with the dataframe containing locations (using the 'id' column)
merged.soilgrids <- 
  left_join(x = fetchedSoilGrid.df, y = database.locations.df,
          by = c("id" = "id")) %>%
  relocate(id, lat, lon, label) %>%
  as_tibble()

# secondly, we join this newly formed dataset to the 'original' dataframe that contains all other information (using coordinates)
database.coords.soilgrids <- 
  left_join(x = merged.soilgrids, y = database.lat.lon,
          by = c("lat" = "latitude",
                 "lon" = "longitude")) %>%
  mutate_at(c("ID.P", "ID.S"), as.numeric) %>%
  relocate(ID.P, ID.S, 
           lat, lon)

# where there is NA values in SoilGrids data on soil variables will be empty. Hence only 107 observations have soil data
```

*Merging (joining) the location-specific soil dataset to the location-specific bioclim dataset (using ID.p and ID.S)*
```{r, eval=FALSE}
merged.database.coords.biophys <- 
  left_join(x = database.coords.soilgrids, y = database.coords.bioclim,
          by = c("ID.P" = "ID.P",
                 "ID.S" = "ID.S"),
          suffix = c("", ".y")) %>% # avoiding the ".x" and ".y" suffix notation
  dplyr::select(-(ends_with(".y"))) %>%
  dplyr::select(-id) %>%
  relocate(ID.P, ID.S, 
           lat, lon,
           Temp, Prec,
           claymean, sandmean, siltmean, bdodmean, nitrogenmean, socmean, phh2omean, cecmean)

# Saving the combined dataset with biopphysical information unto local disc
readr::write_csv(merged.database.coords.biophys, "./DATASET.FROM.SCRIPT/merged.database.coords.biophys.csv")
```

Loading the combined database with location-specific biophysical data from local disc
```{r Loading location-specific biopphysical dataset, warning=FALSE, message=FALSE}

database.biophys <- vroom::vroom("./DATASET.FROM.SCRIPT/merged.database.coords.biophys.csv") %>%
  filter(INCLUDED == TRUE) %>%
  
  mutate(`SAF System Trait type` = recode(ST.TYPE,                      # rename dataframe rows
                                          RBS = "Riparian buffer strips",
                                          SHB = "Line belts *",
                                          MIXED = "Mixed systems",
                                          TIMBER.ARABLE = "Timber - Arable",
                                          BIOMASS.ARABLE = "Biomass - Arable",
                                          NUT.ARABLE = "Nut - Arable",
                                          FRUIT.ARABLE = "Fruit - Arable",
                                          .keep = "all")) %>%
  
  dplyr::mutate(ST.TYPE.PROD.TYPE = "x") %>%
  mutate(ST.TYPE.PROD.TYPE = recode(ST.TYPE,                      # rename dataframe rows
                                    TIMBER.ARABLE = "Biomass",
                                    BIOMASS.ARABLE = "Biomass",
                                    NUT.ARABLE = "Food",
                                    FRUIT.ARABLE = "Food",
                                    RBS = "Multiple",
                                    SHB = "Multiple",
                                    MIXED = "Multiple",
                                    .keep = "all")) 
```


## RQ2.a - How does the system properties temperature and precipitation drive inter-site differences?

**Tree genera - Temperature**

*Preparing the trees data*
Preparing the trees data and adding new columns with group (genera) names
```{r Preparing the tree data, warning=FALSE, message=FALSE}
# loading the trees data
trees <- read_excel("DATA/DATABASE_2.0.xlsx", 
    sheet = "TREE_SPECIES") %>%
  # Generating broad categories of tree species - based on families, genus and hybrids
    separate(TREE.SPECIES, c("TREE.FAMILY.GROUP", "TREE.GENUS.GROUP"), "^\\S*\\K\\s+", remove = FALSE) %>% 
    separate(TREE.GENUS.GROUP, c("TREE.HYBRID.SPEC.1", "TREE.HYBRID.SPEC.2"), "^\\S*\\K\\s+", remove = FALSE) %>%
  
    dplyr::mutate(TREE.FAMILY.GROUP = case_when(
      str_detect(TREE.FAMILY.GROUP, '(?<![:alpha:])UNSPECIFIED(?![:alpha:])') ~ 'Unspecified trees', 
      TRUE ~ as.character(as.character(TREE.FAMILY.GROUP)))) %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  relocate(ID.P, ID.S, TREE.SPECIES, TREE.FAMILY.GROUP) %>%
  mutate_at(c("ID.P", "ID.S"), as.numeric)
```

*Merging tree data with biophys data (including both temperature and precipitation)*
Merging with trees family groups with the biophys database

```{r Merging with trees family groups with the biophys database}
# merging trees data with the biophys database
trees.coords.data <- 
  full_join(database.biopphys, trees,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  dplyr::select(TREE.FAMILY.GROUP, lat, lon, Temp, Prec) %>% # including both temperature and precipitation
  dplyr::distinct(TREE.FAMILY.GROUP, lat, lon, Temp, Prec)
```


```{r PLOTTING - tree genera in relation to temperature, warning=FALSE, message=FALSE}
# number of observations per tree group
trees.coords.data.N <- 
  trees.coords.data %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  filter(Temp > 0) %>%
  group_by(TREE.FAMILY.GROUP) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(TREE.FAMILY.GROUP == max(TREE.FAMILY.GROUP, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 5) %>%
  distinct(N)

# generating plot
trees.temp.violin.plot <- 
trees.coords.data %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  filter(Temp > 0) %>%
  group_by(TREE.FAMILY.GROUP) %>% 
  filter(n() >= 5) %>%

  ggplot(aes(y = Temp/10, x = reorder(TREE.FAMILY.GROUP, Temp))) +
  geom_violin(aes(fill = TREE.FAMILY.GROUP, alpha = 0.8)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = TREE.FAMILY.GROUP, alpha = 1)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 20) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of tree genera across temperature gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Tree genera",
       y = "Annual Mean Temperature [C]") +
  coord_flip()
  

trees.temp.violin.plot
```
**Tree genera - Precipitation**

```{r PLOTTING - tree genera in relation to precipitation, warning=FALSE, message=FALSE}
trees.coords.data %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  filter(Prec > 0) %>%
  group_by(TREE.FAMILY.GROUP) %>% 
  filter(n() >= 10) %>%

  ggplot(aes(y = Prec, x = reorder(TREE.FAMILY.GROUP, Prec))) +
  geom_violin(aes(fill = TREE.FAMILY.GROUP, alpha = 0.8)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = TREE.FAMILY.GROUP, alpha = 1)) +
    stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 1500) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  labs(title = "Distribution of tree family genera across precipitation gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Tree genera",
       y = "Annual Precipitation [mm]") +
  coord_flip()
```

Random lm model to check for relationships
```{r}
model.lm <- lm(Temp ~ TREE.FAMILY.GROUP, data = trees.coords.data)
summary(model.lm)
```


**Crop species groups - Temperature**

*Preparing the crops data*
```{r }
# loading the trees data
crops <- read_excel("DATA/DATABASE_2.0.xlsx", 
    sheet = "CROP_SPECIES") %>%
  # Generating broad categories of crop species - based on broad output product 
  # based on FAO, 2019. FAOSTAT database. http://www.fao.org/faostat/en/#data.
    mutate(CROP.OUTPUT.GROUP = case_when(str_detect(CROP.SPECIES, "Triticum") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Zea") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Hordeum") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Secale") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Avena") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Sorghum") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Fagopyrum") ~ "CEREALS CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Glycine") ~ "PULSES",
                                         str_detect(CROP.SPECIES, "Pisum") ~ "PULSES",
                                         str_detect(CROP.SPECIES, "Cicer") ~ "PULSES",
                                         str_detect(CROP.SPECIES, "Lupinus") ~ "PULSES",
                                         
                                         str_detect(CROP.SPECIES, "Beta") ~ "SUGAR CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Cucurbita") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "UNSPECIFIED.VEGETABLES") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Asparagus") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Brassica oleracea") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Capsicum") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Citrullus") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Cucumis") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Lactuca") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Solanum lycopersicum") ~ "VEGETABLES CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Brassica napus subsp. napus") ~ "OIL CROPS",
                                         str_detect(CROP.SPECIES, "Helianthus") ~ "OIL CROPS",
                                         str_detect(CROP.SPECIES, "Sinapsis") ~ "OIL CROPS",
                                         str_detect(CROP.SPECIES, "Brassica alba") ~ "OIL CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Ribes") ~ "FRUIT CROPS",
                                         str_detect(CROP.SPECIES, "Rubus") ~ "FRUIT CROPS",
                                         str_detect(CROP.SPECIES, "Aronia") ~ "FRUIT CROPS",
                                         str_detect(CROP.SPECIES, "Fragaria") ~ "FRUIT CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Solanum tuberosum") ~ "ROOTS AND TUBER CROPS",
                                         
                                         str_detect(CROP.SPECIES, "HERBS") ~ "OTHER CROPS FOR HUMAN CONS.",
                                         str_detect(CROP.SPECIES, "	SP.BEEF.CATTLE") ~ "OTHER CROPS FOR HUMAN CONS.",
                                         str_detect(CROP.SPECIES, "	SP.DAIRY.CATTLE") ~ "OTHER CROPS FOR HUMAN CONS.",
                                         str_detect(CROP.SPECIES, "	SP.PIG") ~ "OTHER CROPS FOR HUMAN CONS.",
                                         
                                         str_detect(CROP.SPECIES, "Lolium") ~ "FORAGE CROPS",
                                         str_detect(CROP.SPECIES, "Vicia") ~ "FORAGE CROPS",
                                         str_detect(CROP.SPECIES, "Poa") ~ "FORAGE CROPS",
                                         str_detect(CROP.SPECIES, "Festuca") ~ "FORAGE CROPS",
                                         str_detect(CROP.SPECIES, "Medicago") ~ "FORAGE CROPS",
                                         str_detect(CROP.SPECIES, "Panicum") ~ "FORAGE CROPS",
                                         str_detect(CROP.SPECIES, "Trifolium") ~ "FORAGE CROPS",
                                         str_detect(CROP.SPECIES, "HAY.FODDER") ~ "FORAGE CROPS",
                                         str_detect(CROP.SPECIES, "UNSPECIFIED.CLOVERLAY") ~ "FORAGE CROPS",
                                         
                                         str_detect(CROP.SPECIES, "UNSPECIFIED.FALLOW") ~ "FALLOW")) %>%
  # removing 'unreal' species
filter(!grepl("HAY|UNSPECIFIED|HERBS|SP|NA|NS", CROP.SPECIES)) %>% 
# Generating broad categories of crop species - based on genus
  separate(CROP.SPECIES, c("CROP.GENUS.GROUP", "CROP.SPECIES.GROUP"), "^\\S*\\K\\s+", remove = FALSE)
```

*Merging crops data with the biophys data (including both temperature and precipitation)*
Merging dataset on crop species group family groups with the biophys database
```{r Merging with crop groups data with biophys database}
# merging crops data with the biophys database
crops.coords.data <- 
  full_join(database.biophys, crops,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  dplyr::select(CROP.GENUS.GROUP, lat, lon, Temp, Prec) %>% # including both temperature and precipitation
  dplyr::distinct(CROP.GENUS.GROUP, lat, lon, Temp, Prec)
```

```{r PLOTTING - crop groups in relation to temperature, warning=FALSE, message=FALSE}
# number of observations per tree group
crops.coords.data.N <- 
  crops.coords.data %>%
  filter(CROP.GENUS.GROUP != "NA") %>%
  filter(Temp > 0) %>%
  group_by(CROP.GENUS.GROUP) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(CROP.GENUS.GROUP == max(CROP.GENUS.GROUP, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 5) %>%
  distinct(N)

# generating plot
crops.temp.violin.plot <- 
crops.coords.data %>%
  filter(CROP.GENUS.GROUP != "NA") %>%
  filter(Temp > 0) %>%
  group_by(CROP.GENUS.GROUP) %>% 
  filter(n() >= 8) %>%

  ggplot(aes(y = Temp/10, x = reorder(CROP.GENUS.GROUP, Temp))) +
  geom_violin(aes(fill = CROP.GENUS.GROUP, alpha = 0.8)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = CROP.GENUS.GROUP, alpha = 1)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 20) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of crop groups across temperature gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Crop groups",
       y = "Annual Mean Temperature [C]") +
  coord_flip()
  

crops.temp.violin.plot
```

**Crop species groups - Precipitation**

```{r PLOTTING - crop groups in relation to precipitation, warning=FALSE, message=FALSE}
# number of observations per tree group
crops.coords.data.N <- 
  crops.coords.data %>%
  filter(CROP.GENUS.GROUP != "NA") %>%
  filter(Prec > 0) %>%
  group_by(CROP.GENUS.GROUP) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(CROP.GENUS.GROUP == max(CROP.GENUS.GROUP, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 5) %>%
  distinct(N)

# generating plot
crops.prec.violin.plot <- 
crops.coords.data %>%
  filter(CROP.GENUS.GROUP != "NA") %>%
  filter(Prec > 0) %>%
  group_by(CROP.GENUS.GROUP) %>% 
  filter(n() >= 8) %>%

  ggplot(aes(y = Prec, x = reorder(CROP.GENUS.GROUP, Prec))) +
  geom_violin(aes(fill = CROP.GENUS.GROUP, alpha = 0.8)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = CROP.GENUS.GROUP, alpha = 1)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 1500) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of crop groups across precipitation gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Crop groups",
       y = "Annual Precipitation [mm]") +
  coord_flip()
  

crops.prec.violin.plot
```


**SAF system Trait types - Temperature**

*Preparing system trait types data*
```{r Preparing system traits type data}
# using n_individual_study_sites because system trait types vary between sites, as some studies include multiple sites with different species compositions and arrangements.

system.traits.data <- 
  database.lat.lon %>% 
  filter(INCLUDED == TRUE) %>%
  
  # selecting system trait columns
  group_by(`SAF System Trait type`) %>%
  dplyr::select(ID.P, ID.S, `SAF System Trait type`, MANAGEMENT) %>% 
  mutate_at(c("ID.P", "ID.S"), as.numeric)    # <- converting ID columns from characters to numeric

system.traits.data
```

*Merging system trait types data with the biophys data (including both temperature and precipitation)*
Merging dataset on system trait types with the biophys database
```{r Merging system trait types with biophys database}

systrait.coords.data <- 
  full_join(database.biophys, system.traits.data,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  dplyr::select(`SAF System Trait type`, lat, lon, Temp, Prec) %>% # including both temperature and precipitation
  dplyr::distinct(`SAF System Trait type`, lat, lon, Temp, Prec)
```


```{r PLOTTING - system trait types in relation to temperature, warning=FALSE, message=FALSE}
# number of observations per system trait types
systrait.coords.data.N <- 
  systrait.coords.data %>%
  filter(`SAF System Trait type` != "NA") %>%
  filter(Temp > 0) %>%
  group_by(`SAF System Trait type`) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(`SAF System Trait type` == max(`SAF System Trait type`, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 5) %>%
  distinct(N)

# generating plot
systrait.temp.violin.plot <- 
systrait.coords.data %>%
  filter(`SAF System Trait type` != "NA") %>%
  filter(Temp > 0) %>%
  group_by(`SAF System Trait type`) %>% 
  filter(n() >= 5) %>%

  ggplot(aes(y = Temp/10, x = reorder(`SAF System Trait type`, Temp))) +
  geom_violin(aes(fill = `SAF System Trait type`, alpha = 0.8)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = `SAF System Trait type`, alpha = 1)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  #ylim(0, 20) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of SAF system trait types across temperature gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "SAF system trait types",
       y = "Annual Mean Temperature [C]") +
  coord_flip()
  

systrait.temp.violin.plot
```

**System Trait types - Precipitation**

```{r PLOTTING - system trait types in relation to precipitation, warning=FALSE, message=FALSE}
# number of observations per tree group
systrait.coords.data.N <- 
  systrait.coords.data %>%
  filter(`SAF System Trait type` != "NA") %>%
  filter(Prec > 0) %>%
  group_by(`SAF System Trait type`) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(`SAF System Trait type` == max(`SAF System Trait type`, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 5) %>%
  distinct(N)

# generating plot
systrait.prec.violin.plot <- 
systrait.coords.data %>%
  filter(`SAF System Trait type` != "NA") %>%
  filter(Prec > 0) %>%
  group_by(`SAF System Trait type`) %>% 
  filter(n() >= 5) %>%

  ggplot(aes(y = Prec, x = reorder(`SAF System Trait type`, Prec))) +
  geom_violin(aes(fill = `SAF System Trait type`, alpha = 0.8)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = `SAF System Trait type`, alpha = 1)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 1500) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of SAF system trait types across precipitation gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "SAF system trait types",
       y = "Annual Precipitation [mm]") +
  coord_flip()
  

systrait.prec.violin.plot
```

**Merging SAF system trait type plots in relation to bioclim variables**

*Making systrait.bioclim.data in long format*
```{r}
systrait.bioclim.data.long <- 
  systrait.coords.data %>% 
  dplyr::select(-c(lat, lon)) %>%
  drop_na() %>%
  group_by(`SAF System Trait type`) %>%
  summarise(mean_temp = mean(Temp),
            mean_prec = mean(Prec)) %>%
  pivot_longer(cols = -c(`SAF System Trait type`),
                                      names_to = "bioclim_variable",
                                      values_to = "value") 
```


```{r}
systrait.bioclim.data.long %>%
ggplot(aes(x = `SAF System Trait type`, 
           y = value, 
           fill = `SAF System Trait type`,
           alpha = 0.9)) +
  # geom_col() is replacement for geom_bar(stat = "identity")
  geom_col() +
  # independent x-axis scale in each facet, 
  # drop absent factor levels (not the case here)
  facet_wrap(~ bioclim_variable, scales = "free_y", drop = TRUE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 75, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of SAF system trait types across mean bioclim variables",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "SAF system trait types",
       y = "") 

```



**Interrow distances - Latitude**

Interrow distance and latitude
```{r}
interrow.data <- 
database.lat.lon %>%
  filter(CA.DIST.INTERROW != "NA" & latitude != "NA") %>%
  mutate_at('CA.DIST.INTERROW', as.numeric) %>%
  filter(CA.DIST.INTERROW <= 80) %>%
  relocate(CA.DIST.INTERROW, latitude)


lm_eqn <- function(df){
    m <- lm(latitude ~ CA.DIST.INTERROW, interrow.data);
      eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(unname(coef(m)[1]), digits = 2),
              b = format(unname(coef(m)[2]), digits = 2),
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));
}

```

```{r}
lat.interrow.plot <- 
database.lat.lon %>%
  filter(CA.DIST.INTERROW != "NA" & latitude != "NA") %>%
  mutate_at('CA.DIST.INTERROW', as.numeric) %>%
  filter(CA.DIST.INTERROW <= 80) %>%
  
  ggplot(aes(x = CA.DIST.INTERROW,
             y = latitude)) +
  geom_jitter(aes(x = CA.DIST.INTERROW,
             y = latitude, colour = `SAF System Trait type`),
             size = 0.4, 
              alpha = 1, 
              width = 3, 
              height = 4) +
  geom_hdr(xlim = c(0, 80), ylim = c(0, 60), alpha = 0.2) +
  geom_smooth(method = lm, se = FALSE, colour = "black") + # add linear trend line formula = y ~ splines::bs(x, 3)
  geom_text(x = 35, y = 65, label = lm_eqn(data), parse = TRUE, size = 3, col = "black") + 
  labs(x = "Silvoarable system trait type",                       
       y = "n (records)") + 
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none",
        plot.margin = margin(t = 10, r = 0, b = 10, l = 10, unit = "pt"),
        plot.title = element_text(vjust = 0))  +
  scale_y_continuous(breaks = seq(30, 70, 10), limits = c(30, 70)) +
  labs(#title = "Latitude interrow distance",
       x = "Alley crop interrow distance [m]",
       y = "Latitude") 
  #ggtitle("B")

lat.interrow.plot
```

```{r}
world <- map_data("world") %>% 
     filter(region != "Antarctica") # get the world map coordinates using map_data() function from the tidyverse suit of packages

 

world.study.sites <- 
ggplot() +
  geom_map(
    data = world, map = world,
    aes(long, lat, map_id = region),
    color = "white", fill = "lightgray", size = 0.1
  ) +
  geom_point(
    data = database.lat.lon,
    aes(longitude, latitude, color = `SAF System Trait type`),
    alpha = 1, size = 0.2
  ) +
  geom_rect(
    aes(xmin = -15, xmax = 35, ymin = 35.5, ymax = 59), 
    color = "black", fill = NA, inherit.aes = FALSE) +
    theme_bw() +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "top", 
        plot.margin = margin(t = 0, r = 5, b = 0, l = 5, unit = "pt")) +
  #scale_colour_discrete_qualitative(palette = "Dynamic", nmax = 8) +
  guides(color = guide_legend(override.aes = list(size = 1.5))) +
  coord_sf(ylim = c(20, 70), xlim = c(-140, 140)) +
  labs(#title = "Locations of study sites for peer-reviewed silvoarable agroforestry",
      # subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
      # caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Longitude",
       y = "Latitude") 
  #ggtitle("A")

world.study.sites
```

Zooming in on Europe
Now what if we wanted to use the Mollweide projection again as target projection
```{r}
# At first, we set the target CRS and transform the whole worldmap dataset to that CRS.
worldmap <- ne_countries(scale = 'medium', type = 'map_units',
                         returnclass = 'sf')
target_crs <- '+proj=moll'
worldmap_trans <- st_transform(worldmap, crs = target_crs)

# Next, we specify the display window in WGS84 coordinates as longitude / latitude degrees.

disp_win_wgs84 <- st_sfc(st_point(c(-20, 30)), st_point(c(45, 73)),
                         crs = 4326)

# These coordinates can be transformed to our target CRS via st_transform.

disp_win_trans <- st_transform(disp_win_wgs84, crs = target_crs)

# We can extract the coordinates from these points and pass them as limits for the x and y scale respectively. Note also that I set datum = target_crs which makes sure that the graticule is displayed in the target CRS. Otherwise ggplot2 by default displays a WGS84 graticule.

disp_win_coord <- st_coordinates(disp_win_trans)

ggplot() + geom_sf(data = worldmap_trans) +
    coord_sf(xlim = disp_win_coord[,'X'], ylim = disp_win_coord[,'Y'],
             datum = target_crs, expand = FALSE) +
    theme_bw()

```

Calculating the display window for given a center point and zoom level

Instead of specifying a rectangular region of interest, I found it more comfortable to set a center point of interest and specify a “zoom level” which specifies how much area around this spot should be displayed.

I oriented myself on how zoom levels are defined for OpenStreetMap: A level of zero shows the whole world. A level of 1 shows a quarter of the world map. A level of two shows 1/16th of the world map and so on. This goes up to a zoom level of 19. So if z is the zoom level, we see a region that covers 1/4^z of the world. This means the range on the longitude axis that is displayed is 360°/2^z (because the longitude spans the full horizontal circle around the world from -180° to +180°) and the range on the latitude axis is 180°/2^z (latitude spans the half vertical circle from -90° to +90°).

Let’s set a center point zoom_to, a zoom_level and calculate the ranges for longitude and latitude (lon_span and lat_span).

```{r}
# Europe
zoom_to.eu <- c(13.38, 52.52)  # Berlin (from OpenStreetMap)

# North America
zoom_to.na <- c( -94.58, 39.06)  # Kansas (from OpenStreetMap)

zoom_level <- 2


lon_span <- 360 / 2^zoom_level
lat_span <- 180 / 2^zoom_level
```

Now we can calculate the longitude and latitude ranges for the the display window by subtracting/adding the half of the above ranges from/to the zoom center coordinates respectively.

```{r}
# Europe
lon_bounds.eu <- c(zoom_to.eu[1] - lon_span / 2, zoom_to.eu[1] + lon_span / 2)
lat_bounds.eu <- c(zoom_to.eu[2] - lat_span / 2, zoom_to.eu[2] + lat_span / 2)

# North America
lon_bounds.na <- c(zoom_to.na[1] - lon_span / 2, zoom_to.na[1] + lon_span / 2)
lat_bounds.na <- c(zoom_to.na[2] - lat_span / 2, zoom_to.na[2] + lat_span / 2)
```

Europe map
```{r}
# We can now plot the map with the specified display window for zoom level 2, highlighting the zoom center for Europe

map.europe <- 
ggplot() + geom_sf(data = worldmap) +
    geom_sf(data = st_sfc(st_point(zoom_to.eu), crs = 4326),
            color = 'blue', alpha = 0) +
  
    coord_sf(xlim = lon_bounds.eu, ylim = lat_bounds.eu) + theme_bw() +
    geom_point(
    data = database.lat.lon,
    aes(longitude, latitude, color = `SAF System Trait type`),
    alpha = 1, size = 0.5
  ) +
  scale_x_continuous(label = abs) +
    scale_y_continuous(label = abs) +
    theme_bw() +
   theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none",
         plot.margin = margin(t = 0, r = 58, b = 0, l = 0, unit = "pt")) +
 # scale_colour_discrete_qualitative(palette = "Dynamic") +
    labs(#title = "Locations of study sites for peer-reviewed silvoarable agroforestry",
      # subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
      # caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Longitude",
       y = "Latitude") 
  #labs(title = "Locations of study sites in Europe")

map.europe
```


North America map
```{r}
# We can now plot the map with the specified display window for zoom level 2, highlighting the zoom center for North America

map.northamerica <- 
ggplot() + geom_sf(data = worldmap) +
    geom_sf(data = st_sfc(st_point(zoom_to.na), crs = 4326),
            color = 'blue', alpha = 0) +
  
    coord_sf(xlim = lon_bounds.na, ylim = lat_bounds.na) + theme_bw() +
    geom_point(
    data = database.lat.lon,
    aes(longitude, latitude, color = `SAF System Trait type`),
    alpha = 1, size = 0.5
  ) +
  scale_x_continuous(label = abs) +
    scale_y_continuous(label = abs) +
    theme_bw() +
   theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
 # scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Locations of study sites in North America")

map.northamerica
```

Combining the three maps using gridExtra and cowplot
```{r}
# Arrange plots using arrangeGrob
# returns a gtable (gt)
gt <- arrangeGrob(world.study.sites,                               # bar plot spaning two columns
             map.europe, lat.interrow.plot,                               # box plot and scatter plot
             ncol = 2, nrow = 2, 
             layout_matrix = rbind(c(1,1), c(2,3)))

# Add labels to the arranged plots
p <- as_ggplot(gt) +                                # transform to a ggplot
  draw_plot_label(label = c("A", "B", "C"), size = 15,
                  x = c(0, 0, 0.5), y = c(1, 0.5, 0.5)) # Add labels

p
```


**Geographical distribution of SAF systems trait types**




## RQ2.b	How does the system properties soil type and soil quality drive inter-site differences?

- sand
- clay
- soil organic carbon

- bulk density
- pH

*Merging tree data with biophys data (selected soil variables)* 
Merging the trees genera with selected soil variables from the biophys database

```{r Merging with trees family groups with the biophys database}
# merging trees genera data with soil variables
trees.soil.data <- 
  full_join(database.biopphys, trees,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  dplyr::select(TREE.FAMILY.GROUP, lat, lon, 
                claymean, sandmean, bdodmean, socmean, phh2omean) %>% # including both temperature and precipitation
  dplyr::filter(TREE.FAMILY.GROUP != "Unspecified trees") %>%
  dplyr::distinct()
```


**Tree genera - soil sand content**
```{r PLOTTING - tree genera in relation to soil sand content, warning=FALSE, message=FALSE}
# number of observations per tree group
trees.soil.data.data.N <- 
  trees.soil.data %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  filter(sandmean > 0) %>%
  group_by(TREE.FAMILY.GROUP) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(TREE.FAMILY.GROUP == max(TREE.FAMILY.GROUP, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 10) %>%
  distinct(N)

# generating plot
trees.sand.violin.plot <- 
trees.soil.data %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  filter(sandmean > 0) %>%
  group_by(TREE.FAMILY.GROUP) %>% 
  filter(n() >= 10) %>%

  ggplot(aes(y = sandmean, x = reorder(TREE.FAMILY.GROUP, sandmean))) +
  geom_violin(aes(fill = TREE.FAMILY.GROUP, alpha = 0.7)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = TREE.FAMILY.GROUP, alpha = 0.8)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 50) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of tree genera across soil sand content gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Tree genera",
       y = "Soil sand content [%]") +
  coord_flip()
  

trees.sand.violin.plot
```

**Tree genera - soil clay content**
```{r PLOTTING - tree genera in relation to soil clay content, warning=FALSE, message=FALSE}
# number of observations per tree group
trees.soil.data.data.N <- 
  trees.soil.data %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  filter(claymean > 0) %>%
  group_by(TREE.FAMILY.GROUP) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(TREE.FAMILY.GROUP == max(TREE.FAMILY.GROUP, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 10) %>%
  distinct(N)

# generating plot
trees.clay.violin.plot <- 
trees.soil.data %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  filter(claymean > 0) %>%
  group_by(TREE.FAMILY.GROUP) %>% 
  filter(n() >= 10) %>%

  ggplot(aes(y = claymean, x = reorder(TREE.FAMILY.GROUP, claymean))) +
  geom_violin(aes(fill = TREE.FAMILY.GROUP, alpha = 0.7)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = TREE.FAMILY.GROUP, alpha = 0.8)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 50) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of tree genera across soil clay content gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Tree genera",
       y = "Soil clay content [%]") +
  coord_flip()
  

trees.clay.violin.plot
```

**Tree genera - SOC content**
```{r PLOTTING - tree genera in relation to soil soc content, warning=FALSE, message=FALSE}
# number of observations per tree group
trees.soil.data.data.N <- 
  trees.soil.data %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  filter(socmean > 0) %>%
  group_by(TREE.FAMILY.GROUP) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(TREE.FAMILY.GROUP == max(TREE.FAMILY.GROUP, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 10) %>%
  distinct(N)

# generating plot
trees.soc.violin.plot <- 
trees.soil.data %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  filter(socmean > 0) %>%
  group_by(TREE.FAMILY.GROUP) %>% 
  filter(n() >= 10) %>%

  ggplot(aes(y = socmean, x = reorder(TREE.FAMILY.GROUP, socmean))) +
  geom_violin(aes(fill = TREE.FAMILY.GROUP, alpha = 0.7)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = TREE.FAMILY.GROUP, alpha = 0.8)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 50) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of tree genera across soc content gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Tree genera",
       y = "SOC content [%]") +
  coord_flip()
  

trees.soc.violin.plot
```


**Crop groups - soil sand content**

*Merging crop data with biophys data (selected soil variables)* 
Merging the crops genera with selected soil variables from the biophys database

```{r Merging with crops family groups with the biophys database}
# merging crops genera data with soil variables
crops.soil.data <- 
  full_join(database.biopphys, crops,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  dplyr::select(CROP.GENUS.GROUP, lat, lon, 
                claymean, sandmean, bdodmean, socmean, phh2omean) %>% 
  dplyr::distinct()
```


```{r PLOTTING - crop genera in relation to soil sand content, warning=FALSE, message=FALSE}
# number of observations per crop group
crops.soil.data.data.N <- 
  crops.soil.data %>%
  filter(CROP.GENUS.GROUP != "NA") %>%
  filter(sandmean > 0) %>%
  group_by(CROP.GENUS.GROUP) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(CROP.GENUS.GROUP == max(CROP.GENUS.GROUP, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 10) %>%
  distinct(N)

# generating plot
crops.sand.violin.plot <- 
crops.soil.data %>%
  filter(CROP.GENUS.GROUP != "NA") %>%
  filter(sandmean > 0) %>%
  group_by(CROP.GENUS.GROUP) %>% 
  filter(n() >= 20) %>%

  ggplot(aes(y = sandmean, x = reorder(CROP.GENUS.GROUP, sandmean))) +
  geom_violin(aes(fill = CROP.GENUS.GROUP, alpha = 0.7)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = CROP.GENUS.GROUP, alpha = 0.8)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 50) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of crop genera across soil sand content gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "crop genera",
       y = "Soil sand content [%]") +
  coord_flip()
  

crops.sand.violin.plot
```

**Crop groups - soil clay content**
```{r PLOTTING - crop genera in relation to soil clay content, warning=FALSE, message=FALSE}
# number of observations per crop group
crops.soil.data.data.N <- 
  crops.soil.data %>%
  filter(CROP.GENUS.GROUP != "NA") %>%
  filter(claymean > 0) %>%
  group_by(CROP.GENUS.GROUP) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(CROP.GENUS.GROUP == max(CROP.GENUS.GROUP, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 10) %>%
  distinct(N)

# generating plot
crops.clay.violin.plot <- 
crops.soil.data %>%
  filter(CROP.GENUS.GROUP != "NA") %>%
  filter(claymean > 0) %>%
  group_by(CROP.GENUS.GROUP) %>% 
  filter(n() >= 20) %>%

  ggplot(aes(y = claymean, x = reorder(CROP.GENUS.GROUP, claymean))) +
  geom_violin(aes(fill = CROP.GENUS.GROUP, alpha = 0.7)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = CROP.GENUS.GROUP, alpha = 0.8)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 50) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of crop genera across soil clay content gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "crop genera",
       y = "Soil clay content [%]") +
  coord_flip()
  

crops.clay.violin.plot
```

**Crop groups - SOC content**
```{r PLOTTING - crop genera in relation to soil soc content, warning=FALSE, message=FALSE}
# number of observations per crop group
crops.soil.data.data.N <- 
  crops.soil.data %>%
  filter(CROP.GENUS.GROUP != "NA") %>%
  filter(socmean > 0) %>%
  group_by(CROP.GENUS.GROUP) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(CROP.GENUS.GROUP == max(CROP.GENUS.GROUP, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 10) %>%
  distinct(N)

# generating plot
crops.soc.violin.plot <- 
crops.soil.data %>%
  filter(CROP.GENUS.GROUP != "NA") %>%
  filter(socmean > 0) %>%
  group_by(CROP.GENUS.GROUP) %>% 
  filter(n() >= 20) %>%

  ggplot(aes(y = socmean, x = reorder(CROP.GENUS.GROUP, socmean))) +
  geom_violin(aes(fill = CROP.GENUS.GROUP, alpha = 0.7)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = CROP.GENUS.GROUP, alpha = 0.8)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 50) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of crop genera across soil soc content gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "crop genera",
       y = "Soil soc content [%]") +
  coord_flip()
  

crops.soc.violin.plot
```


**SAF system Trait types - sand content**

*Merging system trait types data with the biophys data*
Merging dataset on system trait types with the biophys database
```{r Merging system trait types with biophys database}

systrait.soil.data <- 
  full_join(database.biophys, system.traits.data,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  dplyr::select(`SAF System Trait type`, lat, lon, 
                claymean, sandmean, bdodmean, socmean, phh2omean) %>% 
  dplyr::distinct()
```


```{r PLOTTING - system trait types in relation to sand, warning=FALSE, message=FALSE}
# number of observations per tree group
systrait.sand.data.N <- 
  systrait.soil.data %>%
  filter(`SAF System Trait type` != "NA") %>%
  filter(sandmean > 0) %>%
  group_by(`SAF System Trait type`) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(`SAF System Trait type` == max(`SAF System Trait type`, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 5) %>%
  distinct(N)

# generating plot
systrait.sand.violin.plot <- 
systrait.soil.data %>%
  filter(`SAF System Trait type` != "NA") %>%
  filter(sandmean > 0) %>%
  group_by(`SAF System Trait type`) %>% 
  filter(n() >= 5) %>%

  ggplot(aes(y = sandmean, x = reorder(`SAF System Trait type`, sandmean))) +
  geom_violin(aes(fill = `SAF System Trait type`, alpha = 0.8)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = `SAF System Trait type`, alpha = 1)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 100) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of SAF system trait types across soil sand content gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "SAF system trait types",
       y = "Soil sand content [%]") +
  coord_flip()
  

systrait.sand.violin.plot
```
**SAF system Trait types - clay content**
```{r PLOTTING - system trait types in relation to clay, warning=FALSE, message=FALSE}
# number of observations per tree group
systrait.clay.data.N <- 
  systrait.soil.data %>%
  filter(`SAF System Trait type` != "NA") %>%
  filter(claymean > 0) %>%
  group_by(`SAF System Trait type`) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(`SAF System Trait type` == max(`SAF System Trait type`, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 5) %>%
  distinct(N)

# generating plot
systrait.clay.violin.plot <- 
systrait.soil.data %>%
  filter(`SAF System Trait type` != "NA") %>%
  filter(claymean > 0) %>%
  group_by(`SAF System Trait type`) %>% 
  filter(n() >= 5) %>%

  ggplot(aes(y = claymean, x = reorder(`SAF System Trait type`, claymean))) +
  geom_violin(aes(fill = `SAF System Trait type`, alpha = 0.8)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = `SAF System Trait type`, alpha = 1)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 50) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of SAF system trait types across soil clay content gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "SAF system trait types",
       y = "Soil clay content [%]") +
  coord_flip()
  

systrait.clay.violin.plot
```

**SAF system Trait types - SOC content**
```{r PLOTTING - system trait types in relation to soc, warning=FALSE, message=FALSE}
# number of observations per tree group
systrait.soc.data.N <- 
  systrait.soil.data %>%
  filter(`SAF System Trait type` != "NA") %>%
  filter(socmean > 0) %>%
  group_by(`SAF System Trait type`) %>% 
  mutate(N = n()) %>%
  mutate(N = ifelse(`SAF System Trait type` == max(`SAF System Trait type`, na.rm = T), paste0('n=', N), NA)) %>%
  filter(n() >= 5) %>%
  distinct(N)

# generating plot
systrait.soc.violin.plot <- 
systrait.soil.data %>%
  filter(`SAF System Trait type` != "NA") %>%
  filter(socmean > 0) %>%
  group_by(`SAF System Trait type`) %>% 
  filter(n() >= 5) %>%

  ggplot(aes(y = socmean, x = reorder(`SAF System Trait type`, socmean))) +
  geom_violin(aes(fill = `SAF System Trait type`, alpha = 0.8)) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = `SAF System Trait type`, alpha = 1)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  theme_bw() +
  ylim(0, 50) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of SAF system trait types across soil soc content gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "SAF system trait types",
       y = "Soil soc content [%]") +
  coord_flip()
  

systrait.soc.violin.plot
```

**Merging SAF system trait type plots in relation to soil variables**

*Making systrait.soil.data in long format*
```{r}
systrait.soil.data.long <- 
  systrait.soil.data %>% 
  dplyr::select(-c(lat, lon)) %>%
  drop_na() %>%
  group_by(`SAF System Trait type`) %>%
  summarise(mean_sand = mean(sandmean),
            mean_clay = mean(claymean),
            mean_bd = mean(bdodmean),
            mean_soc = mean(socmean),
            mean_ph = mean(phh2omean)) %>%
  pivot_longer(cols = -c(`SAF System Trait type`),
                                      names_to = "soil_variable",
                                      values_to = "value") 
```


```{r}
systrait.soil.data.long %>%
ggplot(aes(x = `SAF System Trait type`, 
           y = value, 
           fill = `SAF System Trait type`,
           alpha = 0.9)) +
  # geom_col() is replacement for geom_bar(stat = "identity")
  geom_col() +
  # independent x-axis scale in each facet, 
  # drop absent factor levels (not the case here)
  facet_wrap(~ soil_variable, scales = "free_y", drop = TRUE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 75, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of SAF system trait types across mean soil variables",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "SAF system trait types",
       y = "") 

```




### Biodiversity and Ecosystem Services difference as related to location-specific biophysical variables

*Preparing the biophys dataset*
Discretising numeric biophys data into categorical. Adding grouped intervals based on continuous soil variables. This is in order to visualise them in relation to ES for instance.
```{r eval=FALSE}
biophys.categorised <- database.biophys %>%
  # dividing bioclim variables by conversion factor to obtain the correct value
  # not dividing SoilGrids variables becaise; SoilGrids API and maps return values as whole 
  # (integer) numbers to minimize the storage space used. These values are converted by to 
  #produce conventional units by 'fetchSoilGrids()“
  dplyr::mutate(Temp = Temp/10,
                #Prec = Prec/10
                ) %>%
  # discretising using ggplot2::cut_interval(), cut_number() or cut_width()
  mutate(Temp_interval = cut_width(Temp, width = 5, boundary = 0),               # 6 levels
         Prec_interval = cut_width(Prec, width = 300, boundary = 0),              # 6 levels
         
         clay_interval = cut_width(claymean, width = 10, boundary = 0),           # 5 levels
         sand_interval = cut_width(sandmean, width = 20, boundary = 0),           # 5 levels
         silt_interval = cut_width(siltmean, width = 15, boundary = 0),           # 5 levels
         bd_interval = cut_width(bdodmean, width = 0.25, boundary = 0),           # 5 levels
         nitrogen_interval = cut_width(nitrogenmean, width = 3, boundary = 0),    # 5 levels
         soc_interval = cut_width(socmean, width = 50, boundary = 0),             # 5 levels 
         ph_interval = cut_width(phh2omean, width = 1, boundary = 0),             # 5 levels
         cec_interval = cut_width(cecmean, width = 10, boundary = 0)) %>%         # 5 levels
  
  relocate(ID.P, ID.S, 
           `SAF System Trait type`,
           lat, lon,
           Temp, Temp_interval, 
           Prec, Prec_interval,
           claymean, clay_interval,
           sandmean, sand_interval,
           siltmean, silt_interval,
           bdodmean, bd_interval,
           nitrogenmean, nitrogen_interval,
           socmean, soc_interval,
           phh2omean, ph_interval,
           cecmean, cec_interval) 

#glimpse(biophys.categorised)
```

*Renaming ES variables and saving dataset*
```{r eval=FALSE}
biophys.categorised.renamed <- biophys.categorised %>%
  rename("Food (yield)"                      = ES.SUB.PROV.FOOD,
         "Feed"                              = ES.SUB.PROV.FEED,
         "Fibre"                             = ES.SUB.PROV.FIBRE,
         "Fuel (firewood etc.)"              = ES.SUB.PROV.FUEL,
         "Genetic resources"                 = ES.SUB.PROV.GENRES,
         "Biochemicals"                      = ES.SUB.PROV.BIOCHEM,
         "Ornamentals"                       = ES.SUB.PROV.ORNA,
         "Fresh water"                       = ES.SUB.PROV.WATFRESH,
         
         "Air regulation"                    = ES.SUB.REGU.AIR,
         "Climate regulation"                = ES.SUB.REGU.CLIMREG,
         "Carbon sequestration"              = ES.SUB.REGU.CSEQREG,
         "Water regulation"                  = ES.SUB.REGU.WATREG,
         "Nutrient leaching regulation"      = ES.SUB.REGU.NUTRILE,
         "Erosion regulation"                = ES.SUB.REGU.EROREG,
         "Water purification"                = ES.SUB.REGU.WATPUR,
         "Disease regulation"                = ES.SUB.REGU.DISREG,
         "Pest regulation"                   = ES.SUB.REGU.PESTREG,
         "Polination regulation"             = ES.SUB.REGU.POLREG,
         "Natural hazards regulation"        = ES.SUB.REGU.NATHAZREG,
         
         "Soil formation"                    = ES.SUB.SUPP.SOILFORM,
         "Photosynthesis"                    = ES.SUB.SUPP.PHOTSYNT,
         "Primary production"                = ES.SUB.SUPP.PRIMPROD,
         "Nutrient cycling"                  = ES.SUB.SUPP.NUTRICYC,
         "Water cycling"                     = ES.SUB.SUPP.WATCYC,
         
         "Cultural diversity"                = ES.SUB.CULT.CULTDIV,
         "Spiritual value"                   = ES.SUB.CULT.SPIRITVAL,
         "Knowledge systems"                 = ES.SUB.CULT.KNOWLSYS,
         "Educational value"                 = ES.SUB.CULT.EDUVAL,
         "Inspirational value"               = ES.SUB.CULT.INSPIR,
         "Aesthetic value"                   = ES.SUB.CULT.AESTVAL,
         "Social relations"                  = ES.SUB.CULT.SOCREL,
         "Sense of place"                    = ES.SUB.CULT.SENPLACE,
         "Cultural heritage value"           = ES.SUB.CULT.CULTHERIVAL,
         "Recreational and ecotourism"       = ES.SUB.CULT.RECRECOTOUR,
         
         "Provisioning ES"                   = ES.PROV,
         "Regulating ES"                     = ES.REGU,
         "Supporting ES"                     = ES.SUPP,
         "Cultural ES"                       = ES.CULT,
         "Ecosystem Services"                = ES,
 # -----------------------------------------------------------------------------------------------------------------------------------
         "BD.Biodiversity"                   = BD,
         "FLORA.1"                           = BD.SUB.FLORAMACRO,
         "FLORA.2"                           = BD.SUB.FLORAMICRO,
         
         "FAUNA.1"                           = BD.SUB.FAUNAMACRO,
         "FAUNA.2"                           = BD.SUB.FAUNAMICRO,
         
         "Bacteria"                          = BD.SUB.BACTERIA,
         "Fungi"                             = BD.SUB.FUNGI,
 # -----------------------------------------------------------------------------------------------------------------------------------
         "Food"                                       = CAT.SUB.AGRO.YIELD,
         "Biomass"                                    = CAT.SUB.AGRO.BIOMASS,
         "Land equivalent ratio"                      = CAT.SUB.AGRO.LER,
         "Pests"                                      = CAT.SUB.AGRO.PESTS,
         "Diseases"                                   = CAT.SUB.AGRO.DISEASE,
         "Weeds"                                      = CAT.SUB.AGRO.WEEDS,
         "Product quality"                            = CAT.SUB.AGRO.PRODQUAL,
         "Product stability"                          = CAT.SUB.AGRO.PRODSTAB,
         "Mechanisation"                              = CAT.SUB.AGRO.MECHAN,
         "Belowground (crop-tree) competition"        = CAT.SUB.AGRO.CRTRBLOW,
         "Aboveground (crop-tree) light competition"  = CAT.SUB.AGRO.LIGHTCMP,
         "Nutrient use"                               = CAT.SUB.AGRO.NUTRIUSE,
         "Nutrient use effeciency"                    = CAT.SUB.AGRO.NUTRIEF,
         "Breeding and selection"                     = CAT.SUB.AGRO.BRDSELECT,
         
         "Soil quality"                               = CAT.SUB.ENVI.SOILQUAL,
         "Biodiversity"                               = CAT.SUB.ENVI.BIODIV,
         "Carbon stock"                               = CAT.SUB.ENVI.CSTOCK,
         "Greenhouse gas emissions"                   = CAT.SUB.ENVI.GHGEMS,
         "Pollination"                                = CAT.SUB.ENVI.POLLCON,
         "Soil structure"                             = CAT.SUB.ENVI.SOILSTRUCT,
         "Chemical soil components"                   = CAT.SUB.ENVI.SOILCHEM,
         "Biological soil components"                 = CAT.SUB.ENVI.SOILBIO,
         "Soil water"                                 = CAT.SUB.ENVI.SOILWAT,
         "Soil erosion"                               = CAT.SUB.ENVI.SOILEROCO,
         "Soil formations"                            = CAT.SUB.ENVI.SOILFORM,
         "Water quality"                              = CAT.SUB.ENVI.WATQUAL,
         "Water perculation"                          = CAT.SUB.ENVI.WATPERC,
         "Water cyclings"                             = CAT.SUB.ENVI.WATCYC,
         "Water availability"                         = CAT.SUB.ENVI.WATAVAIL,
         "Hydraulic lift"                             = CAT.SUB.ENVI.HYDRAULIFT,
         
         "Economic profit related"                    = CAT.SUB.ECON.PROFIT,
         "Economic management related"                = CAT.SUB.ECON.MANAGE,
         "Economic market related"                    = CAT.SUB.ECON.MARKET,
         
         "Landscape aesthetics"                       = CAT.SUB.SOCUL.LANAES,
         "Recreational and ecotourisms"               = CAT.SUB.SOCUL.RECRECOTOUR,
         "Spiritual values"                           = CAT.SUB.SOCUL.SPIRITVAL,
         "Perception of adoptation"                   = CAT.SUB.SOCUL.PERCEPADOPT,
         "Policy information"                         = CAT.SUB.SOCUL.POLICYINFR,
         
         "Agronomic category"                         = CAT.AGRO,
         "Environmental category"                     = CAT.ENVIRON,
         "Economic category"                          = CAT.ECONOM,
         "Socio-cultural category"                    = CAT.SOCIOCUL) %>%
  # ---------------------------------------------------------------------------------------------------------------------------------
  mutate(Flora = FLORA.1 + FLORA.2, # simplifying flora, fauna groups
         Fauna = FAUNA.1 + FAUNA.2) 

# Saving the biophys.categorised.renamed dataset unto local disc
readr::write_csv(biophys.categorised.renamed, "./DATASET.FROM.SCRIPT/biophys.categorised.renamed.csv")
```

Loading biophys.categorised.renamed dataset from local disc and preparing and merging with crops
```{r Loading dataset with lat long coordinates}
biophys.categorised.renamed <- vroom::vroom("./DATASET.FROM.SCRIPT/biophys.categorised.renamed.csv") %>%
  dplyr::select(
    "SAF System Trait type",
    "ID.P",
    "ID.S",
    "lat", 
    "lon",
    
    "Food (yield)",
    "Feed",
    "Fuel (firewood etc.)",
    "Biodiversity",
    "Disease regulation",
    "Pest regulation",
    "Water cycling",
    "Economic management related",
    "Economic profit related",
    "Aboveground (crop-tree) light competition",
    "Soil structure", 
    "Chemical soil components",
    "Biological soil components",
    "Land equivalent ratio",
    "Climate regulation",
    "Greenhouse gas emissions",
    "Carbon sequestration",
    
    "Temp", "Temp_interval", 
    "Prec", "Prec_interval",
    "claymean", "clay_interval",
    "sandmean", "sand_interval",
    "siltmean", "silt_interval",
    "bdodmean", "bd_interval",
    "nitrogenmean", "nitrogen_interval",
    "socmean", "soc_interval",
    "phh2omean", "ph_interval",
    "cecmean", "cec_interval") 
```

*Preparing ES dataset for merging*
Converting biophys dataset into long format and merging with SAF system traits types and soil sand concentration
```{r}
A_ES <- biophys.categorised.renamed %>%
    dplyr::select(
    "ID.P",
    "ID.S",
    
    "Food (yield)",
    "Feed",
    "Fuel (firewood etc.)",
    "Biodiversity",
    "Disease regulation",
    "Pest regulation",
    "Water cycling",
    "Economic management related",
    "Economic profit related",
    "Aboveground (crop-tree) light competition",
    "Soil structure", 
    "Chemical soil components",
    "Biological soil components",
    "Land equivalent ratio",
    "Climate regulation",
    "Greenhouse gas emissions",
    "Carbon sequestration") %>%
  mutate_if(is.character, as.factor) %>%
  relocate(ID.P, ID.S) %>%
  pivot_longer(cols = c(-ID.P, -ID.S), 
                   names_to = "ES.GROUPS",
                   values_to = "count") %>%
  filter(count == 1)

# --------------------------------------------------------------------------------------------------------------------------
B_SAFTT <- biophys.categorised.renamed %>%
    dplyr::select(
    "ID.P",
    "ID.S",
    
    "SAF System Trait type") 

# --------------------------------------------------------------------------------------------------------------------------
D_JOINED_A_B_ES_SAFTT <- 
  left_join(x = A_ES, y = B_SAFTT,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  relocate(ID.P, ID.S,
           ES.GROUPS, `SAF System Trait type`)
```


**Ecosystem services - soil sand concentration**

*Merging with sand data*
```{r}
# --------------------------------------------------------------------------------------------------------------------------

C_SAND <- biophys.categorised.renamed %>%
    dplyr::select(
    "ID.P",
    "ID.S",
    
    "sand_interval") %>%
  # to avoid exhaustion of R memory
  distinct() %>%
  mutate(sand_interval = recode(sand_interval,                      # rename dataframe rows
                                "[0,20]" = "0 - 20 %",
                                "(20,40]" = "20 - 40 %",
                                "(40,60]" = "40 - 60 %",
                                "(60,80]" = "60 - 80 %",
                                "(80,100]" = "80 - 100 %",
                                .keep = "all"))

# --------------------------------------------------------------------------------------------------------------------------
# Final dataset of selected ecosystem services (including biodiversity and categories data) with soil sand concentration
# --------------------------------------------------------------------------------------------------------------------------
E_JOINED_D_C_SAND <- 
  left_join(x = D_JOINED_A_B_ES_SAFTT, y = C_SAND,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  relocate(ID.P, ID.S,
           ES.GROUPS, `SAF System Trait type`, sand_interval) %>%
  mutate_if(is.character, as.factor) 
```

*Plotting selected ES (including biodiversity and categories data) with sand intervals*
```{r PLOTTING - selected ES (including biodiversity and categories data) with sand intervals, warning=FALSE, message=FALSE}
ES.sand.plot <- E_JOINED_D_C_SAND %>%
  group_by(ES.GROUPS, sand_interval, `SAF System Trait type`) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate_if(is.integer, as.double) %>%
  mutate_if(is.character, as.factor) %>%

  ggplot(aes(x = reorder(`SAF System Trait type`, -count), 
             y = reorder(ES.GROUPS, -count),
             fill = sand_interval)) +
  geom_jitter(aes(size = count), shape = 21, colour = "black",
             alpha = 0.8,
             height = 0.1,
             width = 0.1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
  scale_size_continuous(range = c(1, 10)) +
  scale_fill_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Matrix showing the frequency of associations of studied ecosystem services for different SAF systems across soil sand concentration intervals 
reported by peer-reviewed papers",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0(caption = paste0("* Line belts; shelterbelts, hedgerows and windbreaks. Total number of independent studies reporting on ES = ", total_n_ES$value)),
       x = "Silvoarable System Trait Types",                       
       y = "Selected ecosystem services") +
  facet_grid(.~ sand_interval) 
  
ES.sand.plot
```
**Ecosystem services - SOC content**

*Merging with SOC data*
```{r warning=FALSE, message=FALSE}
# --------------------------------------------------------------------------------------------------------------------------

C_SOC <- biophys.categorised.renamed %>%
    dplyr::select(
    "ID.P",
    "ID.S",
    
    "soc_interval") %>%
  # to avoid exhaustion of R memory
  distinct() %>%
  mutate(soc_interval = recode(soc_interval,                      # rename dataframe rows
                                "[0,50]" = "0 - 50 g/kg",
                                "(50,100]" = "50 - 100 g/kg",
                                "(100,150]" = "100 - 150 g/kg",
                                "(150,200]" = "150 - 200 g/kg",
                                "(200,250]" = "200 - 250 g/kg",
                                "(250,300]"  = "250 - 300 g/kg",
                                .keep = "all"))

# --------------------------------------------------------------------------------------------------------------------------
# Final dataset of selected ecosystem services (including biodiversity and categories data) with soil sand concentration
# --------------------------------------------------------------------------------------------------------------------------
E_JOINED_D_C_SOC <- 
  left_join(x = D_JOINED_A_B_ES_SAFTT, y = C_SOC,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  relocate(ID.P, ID.S,
           ES.GROUPS, `SAF System Trait type`, soc_interval) %>%
  mutate_if(is.character, as.factor) %>%
  mutate_at(vars(soc_interval), funs(factor(., levels=unique(.)))) # convert to factor, sort the facet plots in order of SOC levels
```

*Plotting selected ES (including biodiversity and categories data) with SOC intervals*
```{r PLOTTING - selected ES (including biodiversity and categories data) with SOC intervals, warning=FALSE, message=FALSE}
ES.soc.plot <- E_JOINED_D_C_SOC %>%
  group_by(ES.GROUPS, soc_interval, `SAF System Trait type`) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate_if(is.integer, as.double) %>%
  mutate_if(is.character, as.factor) %>%

  ggplot(aes(x = reorder(`SAF System Trait type`, -count), 
             y = reorder(ES.GROUPS, -count),
             fill = soc_interval)) +
  geom_jitter(aes(size = count), shape = 21, colour = "black",
             alpha = 0.8,
             height = 0.1,
             width = 0.1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
  scale_size_continuous(range = c(1, 10)) +
  scale_fill_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Matrix showing the frequency of associations of studied ecosystem services for different SAF systems across SOC content intervals 
reported by peer-reviewed papers",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0(caption = paste0("* Line belts; shelterbelts, hedgerows and windbreaks. Total number of independent studies reporting on ES = ", total_n_ES$value)),
       x = "Silvoarable System Trait Types",                       
       y = "Selected ecosystem services") +
  facet_grid(.~ soc_interval) 
  
ES.soc.plot
```

**Ecosystem services - temperature**

*Merging with temperature data*
```{r warning=FALSE, message=FALSE}
# --------------------------------------------------------------------------------------------------------------------------

C_TEMP <- biophys.categorised.renamed %>%
    dplyr::select(
    "ID.P",
    "ID.S",
    
    "Temp_interval") %>%
  # to avoid exhaustion of R memory
  distinct() %>%
  mutate(Temp_interval = recode(Temp_interval,                      # rename dataframe rows
                                "[-10,-5]" = "-10 - -5 [°C]",
                                "(-5,0]" = "-5 - 0 [°C]",
                                "(0,5]"  = "0 - 5 [°C]",
                                "(5,10]" = "5 - 10 [°C]",
                                "(10,15]" = "10 - 15 [°C]",
                                "(15,20]" = "15 - 20 [°C]",
                                .keep = "all"))

# --------------------------------------------------------------------------------------------------------------------------
# Final dataset of selected ecosystem services (including biodiversity and categories data) with soil sand concentration
# --------------------------------------------------------------------------------------------------------------------------
E_JOINED_D_C_TEMP <- 
  left_join(x = D_JOINED_A_B_ES_SAFTT, y = C_TEMP,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  relocate(ID.P, ID.S,
           ES.GROUPS, `SAF System Trait type`, Temp_interval) %>%
  mutate_if(is.character, as.factor) %>%
  mutate_at(vars(Temp_interval), funs(factor(., levels=unique(.)))) # convert to factor, sort the facet plots in order of SOC levels
```

*Plotting selected ES (including biodiversity and categories data) with temperature intervals*
```{r PLOTTING - selected ES (including biodiversity and categories data) with temperature intervals, warning=FALSE, message=FALSE}
ES.temp.plot <- E_JOINED_D_C_TEMP %>%
  group_by(ES.GROUPS, Temp_interval, `SAF System Trait type`) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate_if(is.integer, as.double) %>%
  mutate_if(is.character, as.factor) %>%

  ggplot(aes(x = reorder(`SAF System Trait type`, -count), 
             y = reorder(ES.GROUPS, -count),
             fill = Temp_interval)) +
  geom_jitter(aes(size = count), shape = 21, colour = "black",
             alpha = 0.8,
             height = 0.1,
             width = 0.1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
  scale_size_continuous(range = c(1, 10)) +
  scale_fill_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Matrix showing the frequency of associations of studied ecosystem services for different SAF systems across mean annual temperature intervals 
reported by peer-reviewed papers",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0(caption = paste0("* Line belts; shelterbelts, hedgerows and windbreaks. Total number of independent studies reporting on ES = ", total_n_ES$value)),
       x = "Silvoarable System Trait Types",                       
       y = "Selected ecosystem services") +
  facet_grid(. ~factor(Temp_interval, 
                       levels = c("-10 - -5 [°C]", "-5 - 0 [°C]", "0 - 5 [°C]", "5 - 10 [°C]", "10 - 15 [°C]", "15 - 20 [°C]"))) 
  
ES.temp.plot
```



**Ecosystem services - precipitation**

*Merging with precipitation data*
```{r warning=FALSE, message=FALSE}
# --------------------------------------------------------------------------------------------------------------------------

C_PREC <- biophys.categorised.renamed %>%
    dplyr::select(
    "ID.P",
    "ID.S",
    
    "Prec_interval") %>%
  # to avoid exhaustion of R memory
  distinct() %>%
  mutate(Prec_interval = recode(Prec_interval,                      # rename dataframe rows
                                "[0,300]" = "0 - 300 [mm]",
                                "(300,600]" = "300 - 600 [mm]",
                                "(600,900]"  = "600 - 900 [mm]",
                                "(900,1.2e+03]" = "900 - 1200 [mm]",
                                "(1.2e+03,1.5e+03]" = "1200 - 1500 [mm]",
                                "(1.5e+03,1.8e+03]" = "1500 - 1800 [mm]",
                                .keep = "all"))

# --------------------------------------------------------------------------------------------------------------------------
# Final dataset of selected ecosystem services (including biodiversity and categories data) with precipitation
# --------------------------------------------------------------------------------------------------------------------------
E_JOINED_D_C_PREC <- 
  left_join(x = D_JOINED_A_B_ES_SAFTT, y = C_PREC,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  relocate(ID.P, ID.S,
           ES.GROUPS, `SAF System Trait type`, Prec_interval) %>%
  mutate_if(is.character, as.factor) %>%
  mutate_at(vars(Prec_interval), funs(factor(., levels=unique(.)))) # convert to factor, sort the facet plots in order of SOC levels
```

*Plotting selected ES (including biodiversity and categories data) with precipitation intervals*
```{r PLOTTING - selected ES (including biodiversity and categories data) with precipitation intervals, warning=FALSE, message=FALSE}
ES.prec.plot <- E_JOINED_D_C_PREC %>%
  group_by(ES.GROUPS, Prec_interval, `SAF System Trait type`) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate_if(is.integer, as.double) %>%
  mutate_if(is.character, as.factor) %>%

  ggplot(aes(x = reorder(`SAF System Trait type`, -count), 
             y = reorder(ES.GROUPS, -count),
             fill = Prec_interval)) +
  geom_jitter(aes(size = count), shape = 21, colour = "black",
             alpha = 0.8,
             height = 0.1,
             width = 0.1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
  scale_size_continuous(range = c(1, 10)) +
  scale_fill_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Matrix showing the frequency of associations of studied ecosystem services for different SAF systems across annual precipitation intervals 
reported by peer-reviewed papers",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0(caption = paste0("* Line belts; shelterbelts, hedgerows and windbreaks. Total number of independent studies reporting on ES = ", total_n_ES$value)),
       x = "Silvoarable System Trait Types",                       
       y = "Selected ecosystem services") +
  facet_grid(. ~factor(Prec_interval, 
                       levels = c("0 - 300 [mm]", "300 - 600 [mm]", "600 - 900 [mm]", "900 - 1200 [mm]", "1200 - 1500 [mm]", "1500 - 1800 [mm]"))) 
  
ES.prec.plot
```