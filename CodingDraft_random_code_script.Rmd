---
title: "CodingDraft_random_code_script"
author: "Kamau Lindhardt, lbk125"
date: "5/4/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Packages to be installed
```{r}
# install.packages('tidygeocoder')

# install.packages('tidygeocoder')
# install.packages("ggthemes")
# install.packages("wesanderson")
# install.packages("gt")
# install.packages("gtExtras")
# install.packages("DT")
# install.packages("knitr")
# install.packages("kable")
# install.packages("kableExtra")
```

Loading libraries
```{r}
library(tidygeocoder)

library(tidyverse)
library(readxl)
library(ggplot2)
```


---
title: "random_notes"
author: "Kamau Lindhardt, lbk125"
date: "6/20/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---
title: "Literature_review_Sankey_diagram"
author: "Kamau Lindhardt, lbk125"
date: "6/17/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Packages

```{r}
library(readxl)
library(tidyverse)
#devtools::install_github("davidsjoberg/ggsankey")
library(ggsankey)
#install.packages("networkD3")
library(networkD3)
library(dplyr)
library(ggplot2)
```

# Data

```{r}
SANKEY_DATAFRAMES <- read_excel("DATA/SANKEY_DATAFRAME_LITERATURE_REVIEW_PROCESS.xlsx",
    sheet = "SANKEY_DATAFRAME", col_names = TRUE) 

SANKEY_DATAFRAMES


dataframe <- data.frame(
  source=c("Literature_papers","Other_papers", "Total_papers", "Total_papers", "Total_papers", "Total_papers", "Total_papers"), 
  target=c("Total_papers","Total_papers", "Excluded_dedublication", "Excluded_document_type", "Excluded_title_abstract_screening", "Excluded_full_text_screening", "Total_records_for_analysis"), 
  value=c(2088,3, 162, 67, 895, 77, 10)
  )

```

# Building long format data

```{r}
mtcars_df <- SANKEY_DATAFRAMES %>%
  make_long(cyl, vs, am)


df <- SANKEY_DATAFRAMES %>%
  make_long(IN,TOTAL,EXCLUDE_1,ANALYSIS)

df
```

```{r}
ggplot(mtcars_df, aes(x = x, 
               next_x = next_x, 
               node = node, 
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.5, node.color = 1) +
  geom_sankey_label(size = 3.5, color = 1, fill = "white") +
  scale_fill_viridis_d() +
  theme_sankey(base_size = 16) +
  theme(legend.position = "none")
```


















```{r}
nodes = data.frame("name" = 
                     c("Literature sourced from databases",  # (Node 0) Input "papers"                  
                      "Other literature",                    # (Node 1) Input "other"                    
                      "",                                    # (Node 2) Total                           
                      "Node D",                              # (Node 3) Excluded for duplication        
                      "Node E",                              # (Node 4) Continued for the analysis      
                      "Node F",                              # (Node 5) Continued for the analysis      
                      "Node G"))                            # (Node 6) Excluded for document type      



links = as.data.frame(matrix(c(
  # The third number is the value of the node
  # Each row represents a link. The first number
  # represents the node being connected from. 
  # the second number represents the node connected to.
  
  0, 2, 200, 
  1, 2, 5, 
  2, 3, 130, 
  2, 4, 75, 
  4, 5, 30,
  4, 5, 20,
  5, 6, 100),
  byrow = TRUE, ncol = 3))

names(links) = c("source", "target", "value")

sankeyNetwork(Links = links, Nodes = nodes,
              Source = "source", Target = "target",
              Value = "value", NodeID = "name",
             fontSize= 12, nodeWidth = 1) 
```




```{r}
# Create an incidence matrix. Usually the flow goes from the row names to the column names.
# Remember that our connection are directed since we are working with a flow.

# A connection data frame is a list of flows with intensity for each flow
links <- data.frame(
  source=c("group_A","group_B", "group_C", "group_C", "group_C", "group_C"), 
  target=c("group_C","group_C", "group_D", "group_E", "group_F", "group_G"), 
  value=c(35, 595, 95, 159, 123, 99)
  )
 
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
  name=c(as.character(links$source), 
  as.character(links$target)) %>% unique()
)
 
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
 
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              fontSize= 12, nodeWidth = 1,
              sinksRight=FALSE)
p
```





































```{r}
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes_dataframe <- data.frame(
  name=c(as.character(links_dataframe$source), 
  as.character(links_dataframe$target)) %>% unique()
)
```

# Building ready Sankey diagram dataframe

```{r}
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links_dataframe$IDsource <- match(links_dataframe$source, nodes_dataframe$name)-1 
links_dataframe$IDtarget <- match(links_dataframe$target, nodes_dataframe$name)-1
```

# Making the required network

```{r}
# Make the Network
p <- sankeyNetwork(Links = links_dataframe, Nodes = nodes_dataframe,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE)
p
```



Loading data
```{r}
data <- read_excel("DATA/SILVOARABLE_REVIEW_DATA_FOR_ANALYSIS.xlsx", sheet = "STUDY LOCATIONS")
#View(data) 
```

Adding latitude and longitude of study locations
```{r}
data_lat_longs <- data %>%
  geocode(`Location Specification UPDATED MANUALLY`, method = 'osm', lat = latitude , long = longitude)

View(data_lat_longs)
```

Listing studies with missing value in the Latitude column
```{r}
loacation_missing <- data_lat_longs %>%
  filter_all(any_vars(is.na(latitude))) %>%
  relocate(latitude, longitude, `Location Specification`, `Location Specification UPDATED MANUALLY`, StLocation, n, Title)

View(loacation_missing)

# Replacing the observations that have missing values in 'Location Specification' with the information from the general 'Location' column

# The 28 studies with missing information for the latitude location were then manually checked and edited where possible by re-visiting the papers. The previous lines of code was run again. 
```


Visualising the locations on a map
```{r}
ggplot(data_lat_longs, aes(longitude, latitude), color = "grey99") +
  borders("world") + geom_point(color = "orange") +
  #ggrepel::geom_label_repel(aes(label =  `Location Specification UPDATED MANUALLY`)) +
  theme_void()
```

Plotting Matrix of silvoarable agroforestry types and biodiversity variables

```{r}
AC.BD_plot_data %>%
 ggplot(aes(x = reorder(ST.TYPE, -count), y = name)) +
  geom_jitter(aes(size = occurrences_prop, shape = TILLAGE), 
              colour = my_col_single,
              width = 0.25,
              height = 0.25) +
  scale_size_area(max_size = 20) +
  scale_size(range = c(0, 6), guide = "none") +
  labs(x = "Silvoarable system trait type",                       
       y = "Biodiversity sub-indicator") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1), legend.position = "right")  +
  labs(title = "Reported biodiversity indicators for each silvoarable system trait type",
       subtitle = paste("n (study sites) = ", n_individual_study_sites),
       caption = paste("Based on data from the database"),
       x = "Silvoarable system trait types")
```


```{r}
AC.BD_plot_data %>%
  ggballoonplot(x = "ST.TYPE", y = "name", size = "count", fill = "count") +
  scale_fill_gradientn(colors = my_cols_pal_100, name = "No. of obs") +
  guides(size = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1), legend.position = "right")  +
  labs(title = "Matrix of silvoarable agroforestry types and biodiversity variables",
       subtitle = paste("n (study sites) = ", n_individual_study_sites),
       caption = paste("Based on data from the database"),
       x = "Silvoarable systems",
       y = "Biodiversity variables")
```

```{r}
mutate(TREE.FAMILY.GROUP = case_when(str_detect(TREE.SPECIES, "Juglans") ~ "Juglans spp.",
                                       str_detect(TREE.SPECIES, "Juglans") ~ "Juglans spp."))
```


```{r}
BD_database <- database %>%
  dplyr::group_by(AC.TYPE) %>%
  summarise(total_ids = n_distinct(AC.TYPE), 
              total_true_values = n_distinct(AC.TYPE[BD]))


  mutate = rowSums(na.rm = TRUE)

CrossTab_AC.TYPE_BD <- 
  xtabs(~ AC.TYPE + BD.SUB.FLORA + BD.SUB.FAUNAMACRO, 
        data = BD_database) %>%
  as.data.frame.table()


aggregate(AC.TYPE ~ BD.SUB.FLORA + BD.SUB.FAUNAMACRO,
           data = BD_database,
           FUN = length)

# CrossTab_AC.TYPE_BD %>%
#   gather(key, value, -AC.TYPE) %>%
#   mutate(new_cat=paste(AC.TYPE, value, sep="_")) %>%
#   group_by(new_cat, key) %>%
#   tally() %>%
#   spread(key, n) %>%
#   replace(., is.na(.), 0)
```

Creating Matrix of silvoarable agroforestry types and biodiversity variables

```{r}
BD_database <- database %>%
  select(ST.TYPE, MANAGEMENT, starts_with("BD"))

AC.BD_plot_data <- 
  BD_database %>%
  filter(ST.TYPE != "NA" & MANAGEMENT != "NA") %>%
  select(-c(BD.SUB.SPEC, BD)) %>%
  pivot_longer(cols = -c(ST.TYPE, MANAGEMENT)) %>%
  mutate(value = case_when(value == "TRUE" ~ 1,
                           value == "FALSE" ~ 0)) %>%
  na.omit() %>%
  group_by(ST.TYPE, name, MANAGEMENT) %>%
  summarize(count = sum(value)) %>%
  dplyr::mutate(occurrences_prop = (sqrt(count*2))) %>%
  arrange(desc(count)) %>%
  filter(count != 0)
```

Creating contingency matrix of selected variables from the database

```{r}
BD_database <- database %>%
  dplyr::group_by(ST.TYPE)

CrossTab_AC.TYPE_BD <- 
  xtabs(~ ST.TYPE + BD, 
        data = BD_database) %>%
  as.data.frame.table() %>%
  filter(BD != FALSE) %>%
  arrange(desc(Freq)) %>%
  filter(ST.TYPE != "NA")

CrossTab_AC.TYPE_BD
```


```{r}
# Streched contingency table
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Create an Example Data Frame Containing Car x Color data
carnames <- c("bmw","renault","mercedes","seat")
carcolors <- c("red","white","silver","green")
datavals <- round(rnorm(16, mean=100, sd=60),1)
car_data <- data.frame(Car = rep(carnames,4),
                   Color = rep(carcolors, c(4,4,4,4) ),
                   Value=datavals )

car_data
#>         Car  Color Value
#> 1       bmw    red  86.2
#> 2   renault    red 193.5
#> 3  mercedes    red 104.2
#> 4      seat    red 107.8
#> 5       bmw  white 202.9
#> 6   renault  white 127.7
#> 7  mercedes  white  24.1
#> 8      seat  white  58.8
#> 9       bmw silver  73.3
#> 10  renault silver 173.4
#> 11 mercedes silver 121.6
#> 12     seat silver 124.0
#> 13      bmw  green 106.6
#> 14  renault  green  66.6
#> 15 mercedes  green 207.2
#> 16     seat  green 129.9


ggballoonplot(car_data, x = "Car", y = "Color",
              size = "Value", fill = "Value") +
   scale_fill_gradientn(colors = my_cols_pal_10) +
  guides(size = FALSE)
```





Creating Matrix of silvoarable agroforestry types and biodiversity variables

```{r}
BD_database <- database %>%
  filter(INCLUDED == TRUE) %>%
  select(ST.TYPE, MANAGEMENT, starts_with("BD"))

AC.BD_plot_data <- 
  BD_database %>%
  filter(ST.TYPE != "NA" & MANAGEMENT != "NA") %>%
  select(-c(BD.SUB.SPEC, BD)) %>%
  pivot_longer(cols = -c(ST.TYPE, MANAGEMENT)) %>%
  mutate(value = case_when(value == "TRUE" ~ 1,
                           value == "FALSE" ~ 0)) %>%
  na.omit() %>%
  group_by(ST.TYPE, name, MANAGEMENT) %>%
  summarize(count = sum(value)) %>%
  dplyr::mutate(occurrences_prop = (sqrt(count*2))) %>%
  arrange(desc(count)) %>%
  filter(count != 0)
```


Plotting Matrix of silvoarable agroforestry types and biodiversity variables

```{r}
AC.BD_plot_data %>%
 ggplot(aes(x = reorder(ST.TYPE, -count), y = reorder(name, -count), colour = ST.TYPE)) +
  geom_point(aes(size = occurrences_prop, shape = MANAGEMENT),
             position = position_jitter(seed = 55,     
                                        width = 0.25,
                                        height = 0.25)) +
  scale_size_area(max_size = 20) +
  scale_size(range = c(2, 8), guide = "none") +
  scale_color_aaas(guide = "none") +
  scale_shape_manual(values = c(21, 22, 23)) +
  scale_alpha_manual(values = c("1" = 0, "0" = 1)) +
  labs(x = "Silvoarable system trait type",                       
       y = "Biodiversity sub-indicator") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right")  +
  labs(title = "Reported biodiversity indicators for each silvoarable system trait type",
       subtitle = paste("n (study sites) = ", n_individual_study_sites),
       caption = paste("Based on data from the database"),
       x = "Silvoarable system trait types")
```

-----------------------




Loading and preparing the trees datasheets
```{r}
suppressWarnings({ 

database_trees <- read_excel("DATA/DATABASE_2.0.xlsx", 
    sheet = "TREE_SPECIES") %>%
  # Generating broad categories of tree species - based on families, genus and hybrids
    separate(TREE.SPECIES, c("TREE.FAMILY.GROUP", "TREE.GENUS.GROUP"), "^\\S*\\K\\s+", remove = FALSE) %>% 
    separate(TREE.GENUS.GROUP, c("TREE.HYBRID.SPEC.1", "TREE.HYBRID.SPEC.2"), "^\\S*\\K\\s+", remove = FALSE) %>%
  
    dplyr::mutate(TREE.FAMILY.GROUP = case_when(
      str_detect(TREE.FAMILY.GROUP, '(?<![:alpha:])UNSPECIFIED(?![:alpha:])') ~ 'Unspecified trees', 
      TRUE ~ as.character(as.character(TREE.FAMILY.GROUP))))

})
```

Loading and preparing the crops dataset
```{r}
database_crops <- read_excel("DATA/DATABASE_2.0.xlsx", 
    sheet = "CROP_SPECIES") %>%
  # Generating broad categories of crop species - based on broad output product 
  # based on FAO, 2019. FAOSTAT database. http://www.fao.org/faostat/en/#data.
    mutate(CROP.OUTPUT.GROUP = case_when(str_detect(CROP.SPECIES, "Triticum") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Zea") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Hordeum") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Secale") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Avena") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Sorghum") ~ "CEREALS CROPS",
                                         str_detect(CROP.SPECIES, "Fagopyrum") ~ "CEREALS CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Glycine") ~ "PULSES CROPS",
                                         str_detect(CROP.SPECIES, "Pisum") ~ "PULSES CROPS",
                                         str_detect(CROP.SPECIES, "Cicer") ~ "PULSES CROPS",
                                         str_detect(CROP.SPECIES, "Lupinus") ~ "PULSES CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Beta") ~ "SUGAR CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Cucurbita") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "UNSPECIFIED.VEGETABLES") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Asparagus") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Brassica oleracea") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Capsicum") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Citrullus") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Cucumis") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Lactuca") ~ "VEGETABLES CROPS",
                                         str_detect(CROP.SPECIES, "Solanum lycopersicum") ~ "VEGETABLES CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Brassica napus subsp. Napus") ~ "OIL CROPS",
                                         str_detect(CROP.SPECIES, "Helianthus") ~ "OIL CROPS",
                                         str_detect(CROP.SPECIES, "Sinapsis") ~ "OIL CROPS",
                                         str_detect(CROP.SPECIES, "Brassica alba") ~ "OIL CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Ribes") ~ "FRUIT CROPS",
                                         str_detect(CROP.SPECIES, "Rubus") ~ "FRUIT CROPS",
                                         str_detect(CROP.SPECIES, "Aronia") ~ "FRUIT CROPS",
                                         str_detect(CROP.SPECIES, "Fragaria") ~ "FRUIT CROPS",
                                         
                                         str_detect(CROP.SPECIES, "Solanum tuberosum") ~ "ROOTS AND TUBER CROPS",
                                         
                                         str_detect(CROP.SPECIES, "HERBS") ~ "OTHER CROPS FOR HUMAN CONS.",
                                         
                                         str_detect(CROP.SPECIES, "Lolium") ~ "GRASSES AND CROP ROTATION-SPECIFIC CROPS",
                                         str_detect(CROP.SPECIES, "Vicia") ~ "GRASSES AND CROP ROTATION-SPECIFIC CROPS",
                                         str_detect(CROP.SPECIES, "HAY.FODDER") ~ "GRASSES AND CROP ROTATION-SPECIFIC CROPS",
                                         str_detect(CROP.SPECIES, "Poa") ~ "GRASSES AND CROP ROTATION-SPECIFIC CROPS",
                                         str_detect(CROP.SPECIES, "UNSPECIFIED.CLOVERLAY") ~ "GRASSES AND CROP ROTATION-SPECIFIC CROPS",
                                         str_detect(CROP.SPECIES, "Festuca") ~ "GRASSES AND CROP ROTATION-SPECIFIC CROPS",
                                         str_detect(CROP.SPECIES, "Medicago") ~ "GRASSES AND CROP ROTATION-SPECIFIC CROPS",
                                         str_detect(CROP.SPECIES, "Panicum") ~ "GRASSES AND CROP ROTATION-SPECIFIC CROPS"
                                         ))

# View(database)
```

```{r}
database_crops %>%
  group_by(CROP.OUTPUT.GROUP) %>%
  summarise(count = n()) %>%
  arrange(desc(count)) 
```


Distribution of annual crops grown in association with trees in silvoarable studies 

```{r}
plotdata_crops <- database_crops %>% 
  group_by(CROP.OUTPUT.GROUP) %>%
  summarise(count = n()) %>% 
  #group_by(CROP.OUTPUT.GROUP_simplified = replace(CROP.OUTPUT.GROUP, count < 5, "Other species")) %>%
  #summarise(count = sum(count)) %>%
  mutate(pct = (count/sum(count))) %>%
  arrange(desc(-count)) %>%
  ## order factor levels by number, put "Other" to end
  #dplyr::mutate(CROP.OUTPUT.GROUP = forcats::fct_rev(forcats::fct_inorder(CROP.OUTPUT.GROUP)),
  #              CROP.OUTPUT.GROUP = forcats::fct_relevel(CROP.OUTPUT.GROUP, "Other species", after = 8)) %>%
  filter(CROP.OUTPUT.GROUP != "NA")

# Checking that the reordering worked
# levels(plotdata_crops$CROP.OUTPUT.GROUP)
```


```{r}
ggplot(data = plotdata_crops,                          
       aes(x = reorder(CROP.OUTPUT.GROUP, count), y = count)) +                             
  geom_bar(stat = "identity",
           fill = my_col_single) +
  geom_text(aes(label=paste0(round(pct*100, 1),"%")), size=3, vjust = -2) +
  labs(x = "Crop species",                       
       y = "Number") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1), legend.position = "none",
        plot.margin = margin(l = 0 + margin_spacer(plotdata_crops$CROP.OUTPUT.GROUP)))  +
  ylim(c(0, 300)) +
  labs(title = "Distribution of annual crop species grown in association with trees",
       subtitle = paste("n (study sites) = ", n_individual_study_sites),
       caption = paste("Based on data from the database"),
       x = "Crop species")
```

Distribution of tree species in silvoarable studies 

```{r}
plotdata_trees <- database_trees %>% 
  group_by(TREE.FAMILY.GROUP) %>%
  summarise(count = n()) %>% 
  group_by(TREE.FAMILY.GROUP = replace(TREE.FAMILY.GROUP, count < 5, "Other species")) %>%
  summarise(count = sum(count)) %>%
  mutate(pct = (count/sum(count))) %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  arrange(desc(-count)) %>%
  ## order factor levels by number, put "Other" to end
  dplyr::mutate(TREE.FAMILY.GROUP = forcats::fct_rev(forcats::fct_inorder(TREE.FAMILY.GROUP)),
                TREE.FAMILY.GROUP = forcats::fct_relevel(TREE.FAMILY.GROUP, "Other species", after = 15))

# Checking that the reordering worked
levels(plotdata_trees$TREE.FAMILY.GROUP)

  #filter(TREE.SPECIES != "NA" & count > 10) 
```

```{r}
ggplot(data = plotdata_trees,                          
       aes(x = TREE.FAMILY.GROUP,
           y = count)) +                             
  geom_bar(stat = "identity",
           fill = my_col_single) +
  geom_text(aes(label=paste0(round(pct*100, 1),"%")), size=3, vjust = -2) +
  labs(x = "Tree species",                       
       y = "Number") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1), legend.position = "none")  +
  ylim(c(0, 100)) +
  labs(title = "Distribution of tree species",
       subtitle = paste("n (study sites) = ", n_individual_study_sites),
       caption = paste("Based on data from the database"),
       x = "Tree species")
```

Creating Matrix of silvoarable agroforestry types and ecosystem services

```{r}
ES_database <- database %>%
  select(ST.TYPE, ES, ES.PROV, ES.REGU, ES.SUPP, ES.CULT)

AC.ES_plot_data <- 
  ES_database %>%
  filter(ST.TYPE != "NA") %>%
  select(-c(ES)) %>%
  pivot_longer(cols = -ST.TYPE) %>%
  mutate(value = case_when(value == "TRUE" ~ 1,
                           value == "FALSE" ~ 0)) %>%
  na.omit() %>%
  group_by(ST.TYPE, name) %>% 
  summarise(n = n())
```

```{r}
  try <- 
  ES_database %>%
  filter(ST.TYPE != "NA") %>%
  select(-c(ES)) %>%
  pivot_longer(cols = -ST.TYPE) %>%
  mutate(value = case_when(value == "TRUE" ~ 1,
                           value == "FALSE" ~ 0)) %>%
  group_by(ST.TYPE, name) %>%
  summarize(count = sum(value))
```

```{r}

  ggplot(try, aes(x = ST.TYPE, y = name)) +
  geom_point(aes(size = count), shape = 21, colour = "black", fill = "cornsilk") +
  scale_size_area(max_size = 20, guide = "none") 

```


Plotting Matrix of silvoarable agroforestry types and biodiversity variables

```{r}
AC.ES_plot_data %>%
  ggballoonplot(x = "ST.TYPE", y = "name", size = "n", fill = "n") +
  scale_fill_gradientn(colors = my_cols_pal_100, name = "No. of obs") +
  guides(size = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1), legend.position = "right")  +
  labs(title = "Matrix of silvoarable agroforestry types and ecosystem services",
       subtitle = paste("n (study sites) = ", n_individual_study_sites),
       caption = paste("Based on data from the database"),
       x = "Silvoarable systems",
       y = "Ecosystem services")
```

```{r}

ES_database %>%
  filter(ST.TYPE != "NA") %>%
  select(-c(ES)) %>%
  pivot_longer(cols = -ST.TYPE) %>%
  mutate(value = case_when(value == "TRUE" ~ 1,
                           value == "FALSE" ~ 0))
ES_database %>%
ggplot() + 
  geom_jitter(mapping = aes(x = "ST.TYPE", y = "name"),
              width = 0.1, 
              height = 0.1)
```



```{r}
pivot_longer(cols = c(BD, BD.SUB.BACTERIA, BD.SUB.FAUNAMACRO, BD.SUB.FLORA, BD.SUB.FLORAMICRO, BD.SUB.FUNGI, BD.SUB.SOILFAUNA, BD.SUB.SPEC), values_to = "value", names_to = "name") %>%
      
      
  mutate(BD.GROUPS = case_when(str_detect(BD.SUB.INDICATORS, "BD.SUB.FLORA") ~ "FLORA",
                               str_detect(BD.SUB.INDICATORS, "BD.SUB.FLORA") ~ "FLORA",
                               
                               str_detect(BD.SUB.INDICATORS, "BD.SUB.FAUNAMACRO") ~ "FAUNA",
                               str_detect(BD.SUB.INDICATORS, "BD.SUB.SOILFAUNA") ~ "FAUNA",
                               
                               str_detect(BD.SUB.INDICATORS, "BD.SUB.BACTERIA") ~ "BACTERIA",
                               str_detect(BD.SUB.INDICATORS, "BD.SUB.FUNGI") ~ "FUNGI")) %>%
```

```{r}
ggarrange(crops.data.aggr.plot, 
          crops.data.cereals.plot + rremove("x.text"), 
          labels = c("A", "B"),
          ncol = 2, nrow = 2)


combined.crops.plot <- plot_grid(crops.data.aggr.plot + theme(legend.position = "none"), 
                                 crops.data.cereals.plot + theme(legend.position = "none"),
                                 labels = c('A', 'B'), label_size = 12)

plot_grid(combined.crops.plot,
          legend, 
          ncol = 1, 
          nrow = 2,
          rel_heights = c(5, 1),
          rel_widths = c(4, 1),
          hjust = 3,
          vjust = 2)

```

```{r}
database.lat.long.bioclim %>%
  filter(CA.DIST.INTERROW != "NA" & latitude != "NA") %>%
  mutate_at('CA.DIST.INTERROW', as.numeric) %>%
  filter(CA.DIST.INTERROW <= 80) %>%
  ggplot(aes(x = latitude,
             y = CA.DIST.INTERROW)) +
    geom_jitter(width = 3,
              height = 3) +
  geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = TRUE,
              colour = "blue", span = 0.8)  # add linear trend line
  
```

World map of locations
```{r}
worldmap <- ne_countries(scale = 'medium', type = 'map_units',
                         returnclass = 'sf')

# have a look at these two columns only
head(worldmap[c('name', 'continent')])

ggplot() + geom_sf(data = worldmap) + theme_bw()

ggplot() + geom_sf(data = worldmap) +
    coord_sf(xlim = c(-20, 45), ylim = c(30, 73), expand = FALSE) + # expand = FALSE removes the padding around the limits of the display 
    theme_bw()

ggplot() + geom_sf(data = europe_cropped) + theme_bw()
```

```{r}

world2 <- ne_countries(scale = 'medium', returnclass = 'sf') 
class(world2)


gworld <- 
  ggplot(data = world2, 
         aes()) + 
  geom_sf() +
    geom_rect(xmin = -102.15, xmax = -74.12, ymin = 7.65, ymax = 33.97, 
     fill = NA, colour = "black", size = 1.5) +
  scale_fill_viridis_d(option = "plasma") +
  theme(panel.background = element_rect(fill = "azure"),
     panel.border = element_rect(fill = NA)) +
    theme_classic() +
   theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  labs(title = "Locations of study sites")

gworld


```

```{r}
arrowA <- data.frame(x1start = 9, y1start = 12.2, x2end = 7, y2end = 8)

loc.zoom.plot <- 
ggplot() +
    coord_equal(xlim = c(0, 28), ylim = c(0, 20), expand = FALSE) +
    annotation_custom(ggplotGrob(world.study.sites), xmin = -3, xmax = 20, ymin = 5, ymax = 20) +
    annotation_custom(ggplotGrob(map.europe), xmin = -13.1, xmax = 20, ymin = 8, ymax = -0.5) +
    geom_segment(aes(x = x1start, y = y1start, xend = x2end, yend = y2end), data = arrowA, arrow = arrow(), lineend = "round") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
  line = element_blank(),
   plot.margin = margin(t = 0, r = 10, b = 0, l = 30, unit = "pt"))

loc.zoom.plot
```






Combing with latitude vs distance plot
```{r}
combi.plot <- 
  plot_grid(loc.zoom.plot, lat.interrow.plot, 
          ncol = 2,
          nrow = 1,
          labels = c("A", "B"),
          #rel_heights = c(10, 1),
          rel_widths = c(3, 1))

combi.plot
```

```{r}
s <- plot_spacer()

lat.dist.combi.plot <- (
world.study.sites + lat.interrow.plot + s + s + s +
s + s + s + s + s +
  plot_layout(widths = c(200, 40, 1, 1, 1), heights = unit(c(2, 0.001), c('cm', 'null'))))
```


```{r}
ggarrange(lat.dist.combi.plot, map.europe + rremove("x.text"), 
          ncol = 1, nrow = 2)
```

```{r}
grid.arrange(world.study.sites,                             # First row with one plot spaning over 2 columns
             arrangeGrob(map.europe, lat.interrow.plot, ncol = 2), # Second row with 2 plots in 2 different columns
             nrow = 2)                       # Number of rows
```


```{r}
ggpubr::ggdotchart(pub.year.data, x = "yeardate", y = "no_studies_accum",
             add = "segments",
             sorting = "none",
             dot.size = 6,                                 # Large dot size
           font.label = list(color = "white", size = 9, 
                             vjust = 0.5),
           ggtheme = theme_bw(),                        # ggplot2 theme
           ) +
    ggplot2::scale_x_datetime(labels = date_format("%Y"))

```


```{r}
url = "https://files.isric.org/soilgrids/latest/data/" # Path to the webDAV data.
```

Set variables of interest:

Let’s define nitrogen as our variable of interest. We also need to define the depth as well as the quantile.

Let’s note that SoilGrids maps have associated uncertainties as any product derived from a modelling approach. The prediction uncertainty is quantified by probability distributions. For each property and each standard depth interval this distribution is characterised by four parameters as follows:

Q0.05 - 5% quantile;
Q0.50 - median of the distribution;
mean - mean of the distribution;
Q0.95 - 95% quantile.
At the url, we can clic on the nitrogen option. We will get:

We need to define the url for the ISRIC webDAD site:



```{r}
voi = "nitrogen" # variable of interest
depth = "15-30cm"
quantile = "mean"

(variable = paste(url, voi, sep=""))
```

```{r}
(layer = paste(variable,depth,quantile, sep="_")) # layer of interest 
```

```{r}
(vrt_layer = paste(layer, '.vrt', sep=""))
```

3. Example 1: Describe the layer
We can use the raster library to get layer’s info:

```{r}
nitro = raster::raster("https://files.isric.org/soilgrids/latest/data/nitrogen/nitrogen_15-30cm_mean.vrt")
#nitro = raster(vrt_layer)
```

```{r}
## overlay the centroid points and the stem locations on the CHM plot
# plot the chm

raster::plot(nitro)

## plotting details: cex = point size, pch 0 = square
# plot square around the centroid
points(centroids$easting,centroids$northing, pch=0, cex = 2 )
# plot location of each tree measured
points(vegStr$easting,vegStr$northing, pch=19, cex=.5, col = 2)
```
```{r}
deptos <- st_read("./ne_10m_admin_0_map_units/ne_10m_admin_0_map_units.shp")
```

```{r}
(boyaca <- dplyr::filter(deptos, SOV_A3 =="BOL"))

igh='+proj=igh +lat_0=0 +lon_0=0 +datum=WGS84 +units=m +no_defs'
boyaca_igh <- st_transform(boyaca, igh)

(bbox <- st_bbox(boyaca_igh))
```

```{r}
(bbox <- st_bbox(boyaca_igh))
```

Now, let’s use the bbox data to define the boundary box limits as used by GDAL. By the way, this is one of the trickiest parts of using GDAL.

```{r}
## ul means upper left
## lr means lower right
ulx = bbox$xmin
uly = bbox$ymax
lrx= bbox$xmax
lry = bbox$ymin
(bb <- c(ulx, uly, lrx, lry))
```

Now, we can use gdal_translate function to download the nitro layer.

```{r}
sg_url="/vsicurl/https://files.isric.org/soilgrids/latest/data/"
datos = 'nitrogen/nitrogen_15-30cm_mean.vrt'
lfile = "./nitro_ntest_igh_15_30.tif"
```

Note that the following task may be take several minutes:

```{r}
gdal_translate(paste0(sg_url,datos), lfile ,
               tr=c(250,250),
               projwin=bb,
               projwin_srs =igh,
               verbose=TRUE)
```


Let’s read the downloaded layer:

```{r}
(boyaca_nitro <- raster::raster(lfile)/100)
```

Now, let’s reproject the layer using WGS84 geographic coordinates. This is needed to plot it using mapview:

```{r}
#crs_wgs84 = "+proj=longlat +datum=WGS84 +no_defs" 
crs_wgs84 = CRS('+init=EPSG:4326')
(boyaca_nitro_wgs84 = raster::projectRaster(boyaca_nitro, crs=crs_wgs84))
```

```{r}
hist(boyaca_nitro_wgs84)
```

```{r}
pal <- colorRampPalette(brewer.pal(9, "BrBG"))

mapview(boyaca_nitro_wgs84, col.regions = pal(100), at = seq(0, 6, 1), maxpixels =  1327941,legend = TRUE) 
```

```{r}
bb=c(-337500.000,1242500.000,152500.000,527500.000) # Example bounding box (homolosine) for Ghana
igh='+proj=igh +lat_0=0 +lon_0=0 +datum=WGS84 +units=m +no_defs' # proj string for Homolosine projection

sg_url="/vsicurl?max_retry=3&retry_delay=1&list_dir=no&url=https://files.isric.org/soilgrids/latest/data/"

```

To a geotiff in Homolosine
This GDAL command will create a local geotiff in the Homolosine projection

```{r}
try <- gdal_translate(paste0(sg_url,'ocs/ocs_0-30cm_mean.vrt'),
    "./crop_roi_igh_r.tif",
    tr=c(250,250),
    projwin=bb,
    projwin_srs =igh,
    verbose=TRUE)

try
```


To a geotiff in a different projection
The following commands describe a workflow to obtain a VRT or a GeoTiff for an area of interest in a projection of your choice. In this example we will use EPSG=4326

To local VRT in homolosine (directly from the webdav connection)
The first step is to obtain a VRT for the area of interest in the Homolosine projection. We suggest to use VRT for the intermediate steps to save space and computation times.

```{r}
try2 <- gdal_translate(paste0(sg_url,'ocs/ocs_0-30cm_mean.vrt'),
    "./crop_roi_igh_r.vrt",
    of="VRT",tr=c(250,250),
    projwin=bb,
    projwin_srs =igh,
    verbose=TRUE)

try2
```

To a VRT in, for example, LatLong
The following command will generate a VRT in the projection of your choice:
```{r}
try3 <- gdalwarp("./crop_roi_igh_r.vrt",
    "./crop_roi_ll_r.vrt", 
    s_src=igh, 
    t_srs="EPSG:4326", 
    of="VRT")

```

To a final Geotiff
The following command will generate a Geotiff in the projection of your choice for the area of interest defined above

```{r}
try4 <- gdal_translate("./crop_roi_ll_r.vrt",  
    "./crop_roi_ll_r.tif", 
    co=c("TILED=YES","COMPRESS=DEFLATE","PREDICTOR=2","BIGTIFF=YES"))

try4
```

Read in R
Finally you can read any of the generated VRTs or GeoTiffs in R for further analysis

```{r}
r=readGDAL("./crop_roi_igh_r.vrt") # Or any other of the files produce above
```

To download a global geotiff in Homolosine projection
```{r}
gdal_translate(paste0(sg_url,'ocs/ocs_0-30cm_mean.vrt'),
    "./crop_roi_igh_r.tif",
    verbose=TRUE)

```

```{r}
url = "https://files.isric.org/soilgrids/latest/data/" # Path to the webDAV data.

voi = "nitrogen" # variable of interest
depth = "15-30cm"
quantile = "mean"

(variable = paste(url, voi, sep=""))

(layer = paste(variable,depth,quantile, sep="_")) # layer of interest 

(vrt_layer = paste(layer, '.vrt', sep=""))
```

```{r}
nitro = raster::raster("https://files.isric.org/soilgrids/latest/data/nitrogen/nitrogen_15-30cm_mean.vrt")
#nitro = raster(vrt_layer)
```

```{r}
tif.cog = paste0("/vsicurl/https://s3.eu-central-1.wasabisys.com/africa-soil/layers30m/",
                 nitro)
```

```{r}
SoilGrid.fun <- 
  function (Data, ID = NA, Projected = F) 
{
    Data <- data.frame(Data)
    Data <- Data[!(is.na(Data$latitude) | is.na(Data$longitude) | 
        Data$Buffer == "" | is.na(Data$Buffer)), ]
    if (!is.na(ID)) {
        SS <- unique(Data[, c("latitude", "longitude", ID, "Buffer")])
    }
    else {
        SS <- unique(Data[, c("latitude", "longitude", "Buffer")])
    }
    CRS.old <- "+init=epsg:4326"
    CRS.new <- "+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
    points <- sp::SpatialPoints(cbind(SS$longitude, SS$latitude), 
        proj4string = CRS(CRS.old))
    points <- sp::spTransform(points, CRS.new)
    pbuf1 <- lapply(1:nrow(SS), FUN = function(i) {
        pbuf <- rgeos::gBuffer(points[i], widt = SS$Buffer[i])
        pbuf <- sp::spChFIDs(pbuf, paste(i, row.names(pbuf), 
            sep = "."))
    })
    rownames(SS) <- lapply(pbuf1, names)
    pbuf1 <- sp::SpatialPolygons(lapply(pbuf1, function(x) {
        x@polygons[[1]]
    }), proj4string = CRS(CRS.new))
    pbuf1 <- sp::SpatialPolygonsDataFrame(pbuf1, data = SS)
    if (Projected == T) {
        return(pbuf1)
    }
    else {
        pbuf1 <- sp::spTransform(pbuf1, CRS(CRS.old))
        return(pbuf1)
    }
}
```


```{r}
SoilsLayers <- fread("./DATA/ISRIC_soildata.csv")

database.lat.long.bioclim <- database.lat.long.bioclim %>%
  dplyr::mutate(Buffer = 25000) %>%
  as.data.frame()

database.locations <- terra::vect(SoilGrid.fun(Data = database.lat.long.bioclim, 
                                               ID = "ID.P", 
                                               Projected = F))

database.locations.G<-terra::project(database.locations,  "+proj=longlat +datum=WGS84 +no_defs")
database.locations.P<-terra::project(database.locations,  "+proj=laea +lat_0=5 +lon_0=20 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs")

CRS <- terra::crs(database.locations, proj4 = T)

tif.cog = paste0("https://files.isric.org/soilgrids/latest/data/",
                 SoilsLayers[,file])
```

```{r}
SoilsLayers <- fread("./DATA/ISRIC_soildata.csv")

database.locations.df <- database.lat.long.bioclim %>%
  as.data.frame()

database.locations.proj.G <- terra::project(database.locations,  
                                            "+proj=longlat +datum=WGS84 +no_defs")

database.locations.proj.P <- terra::project(database.locations,  
                                            "+proj=laea +lat_0=5 +lon_0=20 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs")

database.locations.crs <- terra::crs(database.locations, proj = T)

tif.cog = paste0("https://files.isric.org/soilgrids/latest/data/",
                 SoilsLayers[,file])
```

```{r}
# specifying saving directory

SaveDir<-"Downloads/Tables - Test/"

if(!dir.exists(SaveDir)){
  dir.create(SaveDir,recursive = T)
}
```


```{r}
tif.cog<-tif.cog[1:length(tif.cog)]
SoilsLayers<-SoilsLayers[1:nrow(SoilsLayers)]
```

```{r}
t.rast <- terra::extract(terra::rast(tif.cog[1]), database.locations.proj.P)
```

```{r}
system.time(

Site.Extraction <- 
  
  rbindlist(lapply(1:length(tif.cog), function(i){


      File<-paste0(SaveDir,gsub(".vrt",".vrt",SoilsLayers[i,file]),".RData")

      File2<-paste0(SaveDir,"Raw - ",gsub(".vrt",".vrt",SoilsLayers[i,file]),".RData")

      if(!file.exists(File)){

      print(paste0("Downloading variable  ",i,"/",length(tif.cog)," | ",gsub(".vrt",".vrt",SoilsLayers[i,file])))


      if(grepl("proj.laea",tif.cog[i])){

        Site <- terra::extract(terra::rast(tif.cog[i]), database.locations.proj.P)
      }else{
        Site <- terra::extract(terra::rast(tif.cog[i]), database.locations.proj.G)
      }

        Site<-data.table(Site)

        save(Site,file=File2,overwrite=T)


        colnames(Site)[2]<-"Value"
        by=ID.P
        Variable:=gsub(".vrt","",SoilsLayers[i,file])

        save(table,file=File)


        }else{
          print(paste0("Loading saved variable  ",i,"/",length(tif.cog)," | ",gsub(".vrt","",SoilsLayers[i,file])))

          table<-miceadds::load.Rdata2(paste0(gsub(".vrt","",SoilsLayers[i,file]),".RData"),path=SaveDir)
        }

      table
    }))

)
```

Trying again using the 'soilDB' package

```{r}
your.points <- data.frame(id  = c("A", "B"), 
                           lat = c(37.9, 38.1), 
                           lon = c(-120.3, -121.5), 
                           stringsAsFactors = FALSE)

x <- fetchSoilGrids(your.points,
                    progress = TRUE)
 

plotSPC(x, name = NA, color = "claymean")
```

```{r}
webdav_path = '/vsicurl?max_retry=3&retry_delay=1&list_dir=no&url=https://files.isric.org/soilgrids/latest/data/'
```

Read in point data and re-project to Homolosine

```{r}


#data=read.csv("my_points_data.csv")
data = database.lat.long

spdata = st_as_sf(data, coords = c("longitude", "latitude"), crs = 4326)

igh = '+proj=igh +lat_0=0 +lon_0=0 +datum=WGS84 +units=m +no_defs'
spdata_igh = st_transform(spdata, igh)

data_igh = data.frame(st_coordinates(spdata_igh),
                      id = spdata_igh$ID.P)
```

Use gdallocationinfo to get the values from the pixels

```{r}
voi = "soc" # variable of interest
depth = "0-5cm"
layer = "mean"

voi_layer = paste(voi,depth,layer, sep="_") # layer of interest 
```


```{r}
fun_pixel_values = function(rowPX,data,VOI,VOI_LYR){
    as.numeric(
        gdallocationinfo(
            srcfile=paste0(webdav_path,"/",VOI,"/", VOI_LYR,".vrt"),
            x=data[rowPX,"X"],
            y=data[rowPX,"Y"],
            geoloc=TRUE,
            valonly=TRUE))
}

value_pixels = unlist(lapply(1:3, function(x){fun_pixel_values(x, data_igh, voi, voi_layer)}))

```


The value_pixels vector can be binded with data_igh paying attention to order. gdallocationinfo can also return more information, including the coordinates themselves for a safer workflow.


```{r}
library(ggridges)


spatial.arrange.data %>%
  drop_na(CA.DIST.INTERROW) %>%
  dplyr::filter(CA.DIST.INTERROW <= 100) %>%
  mutate(text = fct_reorder(ST.TYPE, CA.DIST.INTERROW)) %>%
  ggplot(aes(y = reorder(ST.TYPE, -CA.DIST.INTERROW), 
             x = CA.DIST.INTERROW,  
             fill = ST.TYPE)) +
  geom_density_ridges(alpha = 0.6, 
                      quantile_lines = TRUE, quantiles = 2) +
  theme_ridges() + 
  scale_fill_manual(
    values = colorspace::qualitative_hcl(6, palette = "Dynamic"))
  
  scale_fill_continuous(colours = colorspace::qualitative_hcl(6))

  scale_fill_viridis(name = "Interrow distance", option = "C") 

   scale_fill_discrete(colours = colorspace::qualitative_hcl(6))
```

Plot try exploration

```{r}
# using n_individual_study_sites because some studies include multiple sites with different system traits, species compositions and arrangements. 

database.lat.long.soilgrids %>%
ggplot(aes(lon, lat), color = "grey99") +
  borders("world") + 
  geom_point(aes(color = ST.TYPE), size = 0.5, alpha = 0.8) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
  scale_fill_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Visualising peer-reviewed silvoarable paper' study site locations on a map",
       subtitle = paste("n (study sites) = ", n_individual_study_sites),
       x = "Longitude",                       
       y = "Latitude")
```



```{r}
database.lat.long.soilgrids %>% 
  dplyr::arrange(id) %>%
  ggplot(aes(claymean, fill = MANAGEMENT)) +
  geom_histogram(bins = 10)
```


```{r}
n_obs <- as.numeric(crops.data.n_obs$n[1])
crops.data.n_obs['Total_n_obs'] = n_obs

crops.data.cereals.group <- crops.data.cereals %>% group_by(CROP.SPECIES) 
crops.data.cereals.group['pct'] <- crops.data.cereals.group$count/crops.data.cereals.group$Total_n_obs 


  group_by(CROP.SPECIES) %>% 
  mutate(pct = (count/crops.data.n_obs)) %>%
  arrange(desc(count)) %>%
  filter(pct >= 0.10)

summarise(count = n()) %>%
  add_tally(wt = count) %>%
```

```{r}
str_detect(name, "Agronomic category") ~ "Agronomic",
                  str_detect(name, "Environmental category") ~ "Environmental",
                  str_detect(name, "Economic category") ~ "Economic",
                  str_detect(name, "Socio-cultural category") ~ "Socio-cultural",
                  str_detect(name, "Provisioning ES") ~ "Provisioning ES",
                  str_detect(name, "Regulating ES") ~ "Regulating ES",
                  str_detect(name, "Supporting ES") ~ "Supporting ES",
                  str_detect(name, "Cultural ES") ~ "Cultural ES"))
```


```{r}
# category.data.renamed
# ecosystem.data.renamed

joined.category.ecosystem <- left_join(x = category.data.renamed, y = ecosystem.data.renamed, 
            by = c("ID.P" = "ID.P"))  %>%
  relocate(ID.P) 

category.ecosystem.long <- joined.category.ecosystem %>%
  pivot_longer(!ID.P,
               names_to = "name",
               values_to = "value") %>%
  mutate(INPUT.OUTPUT.ES = case_when(
    # --------------------------------------------------------------------------------------------------- Regular INPUT services
                  str_detect(name, "Erosion regulation") ~ "INPUT.ES",
                  str_detect(name, "Disease regulation") ~ "INPUT.ES",
                  str_detect(name, "Pest regulation") ~ "INPUT.ES",
                  str_detect(name, "Polination regulation") ~ "INPUT.ES",
                  str_detect(name, "Soil formation") ~ "INPUT.ES",
                  str_detect(name, "Nutrient use effeciency") ~ "INPUT.ES",
                  str_detect(name, "Land equivalent ratio") ~ "INPUT.ES",
                  str_detect(name, "Economic profit related") ~ "INPUT.ES",
                  str_detect(name, "Biodiversity") ~ "INPUT.ES",
    # ---------------------------------------------------------------------------------------------------             
                  str_detect(name, "Soil structure") ~ "INPUT.ES",
                  str_detect(name, "Water availability") ~ "INPUT.ES",
                  str_detect(name, "Hydraulic lift") ~ "INPUT.ES",
                  str_detect(name, "Water cycling") ~ "INPUT.ES",
                  str_detect(name, "Nutrient cycling") ~ "INPUT.ES",
    # --------------------------------------------------------------------------------------------------- Regular OUTPUT services
                  str_detect(name, "Economic profit related") ~ "OUTPUT.ES",
                  str_detect(name, "Food") ~ "OUTPUT.ES",
                  str_detect(name, "Fibre") ~ "OUTPUT.ES",
                  str_detect(name, "Fuel (firewood etc.)") ~ "OUTPUT.ES",
                  str_detect(name, "Climate regulation") ~ "OUTPUT.ES",
                  str_detect(name, "Carbon sequestration") ~ "OUTPUT.ES",
                  str_detect(name, "Water regulation") ~ "OUTPUT.ES",
                  str_detect(name, "Nutrient leaching regulation") ~ "OUTPUT.ES",
                  str_detect(name, "Landscape aesthetics") ~ "OUTPUT.ES",
                  str_detect(name, "Recreational and ecotourism") ~ "OUTPUT.ES",
                  str_detect(name, "Product quality") ~ "OUTPUT.ES",
                  str_detect(name, "Pollination") ~ "OUTPUT.ES",
                  str_detect(name, "Product stability") ~ "OUTPUT.ES",
                  str_detect(name, "Recreational and ecotourisms") ~ "OUTPUT.ES",
                  str_detect(name, "Spiritual values") ~ "OUTPUT.ES",
                  str_detect(name, "Spiritual value") ~ "OUTPUT.ES",
                  str_detect(name, "Educational value") ~ "OUTPUT.ES",
    # ---------------------------------------------------------------------------------------------------               
                  str_detect(name, "Economic management related") ~ "INPUT.ES",              
                  str_detect(name, "Food (yield)") ~ "OUTPUT.ES",
                  str_detect(name, "Feed") ~ "OUTPUT.ES",
                  str_detect(name, "Biomass") ~ "OUTPUT.ES",
                  str_detect(name, "Biochemicals") ~ "OUTPUT.ES",
                  str_detect(name, "Ornamentals") ~ "OUTPUT.ES")) %>%
    
    # --------------------------------------------------------------------------------------------------- 
    # Specifying ES + CAT groups into; ES = prov, regu, supp and cult + CAT = agronomy, environment, economic and socio-cultural
    # --------------------------------------------------------------------------------------------------- 
  mutate(ES.CAT.GROUPS = case_when(
    str_detect(name, "Food") ~ "Povisioning ES",
    str_detect(name, "Feed") ~ "Povisioning ES",
    str_detect(name, "Fibre") ~ "Povisioning ES",
    str_detect(name, "Fuel") ~ "Povisioning ES",               # "Fuel (firewood etc.)"
    str_detect(name, "Genetic resources") ~ "Povisioning ES",
    str_detect(name, "Biochemicals") ~ "Povisioning ES",
    str_detect(name, "Ornamentals") ~ "Povisioning ES",
    str_detect(name, "Fresh water") ~ "Povisioning ES",
 
    # --------------------------------------------------------------------------------------------------- 
    str_detect(name, "Air regulation") ~ "Regulating ES",
    str_detect(name, "Climate regulation") ~ "Regulating ES",
    str_detect(name, "Carbon sequestration") ~ "Regulating ES",
    str_detect(name, "Water regulation") ~ "Regulating ES",
    str_detect(name, "Water purification") ~ "Regulating ES",
    str_detect(name, "Nutrient leaching regulation") ~ "Regulating ES",
    str_detect(name, "Erosion regulation") ~ "Regulating ES",
    str_detect(name, "Water availability") ~ "Regulating ES",
    str_detect(name, "Disease regulation") ~ "Regulating ES",
    str_detect(name, "Pest regulation") ~ "Regulating ES",
    str_detect(name, "Polination regulation") ~ "Regulating ES",
    str_detect(name, "Polination regulation") ~ "Regulating ES",
    str_detect(name, "Natural hazards regulation") ~ "Regulating ES",
    # ---------------------------------------------------------------------------------------------------                 
                  
    str_detect(name, "Soil formation") ~ "Supporting ES", 
    str_detect(name, "Photosynthesis") ~ "Supporting ES",
    str_detect(name, "Primary production") ~ "Supporting ES",   
    str_detect(name, "Nutrient cycling") ~ "Supporting ES",
    str_detect(name, "Water cycling") ~ "Supporting ES",
    # --------------------------------------------------------------------------------------------------- 
    
    str_detect(name, "Cultural diversity") ~ "Cultural ES",
    str_detect(name, "Spiritual value") ~ "Cultural ES",
    str_detect(name, "Knowledge systems") ~ "Cultural ES",
    str_detect(name, "Educational value") ~ "Cultural ES",
    str_detect(name, "Inspirational value") ~ "Cultural ES",
    str_detect(name, "Aesthetic value") ~ "Cultural ES",
    str_detect(name, "Social relations") ~ "Cultural ES",
    str_detect(name, "Sense of place") ~ "Cultural ES",
    str_detect(name, "Cultural heritage value") ~ "Cultural ES",
    str_detect(name, "Recreational and ecotourism") ~ "Cultural ES",
    # --------------------------------------------------------------------------------------------------- 
    
    str_detect(name, "Food (yield)") ~ "Agronomy",
    str_detect(name, "Biomass") ~ "Agronomy",
    str_detect(name, "Land equivalent ratio") ~ "Agronomy",
    str_detect(name, "Pests") ~ "Agronomy",
    str_detect(name, "Diseases") ~ "Agronomy",
    str_detect(name, "Weeds") ~ "Agronomy",
    str_detect(name, "Product quality") ~ "Agronomy",
    str_detect(name, "Product stability") ~ "Agronomy",
    str_detect(name, "Mechanisa") ~ "Agronomy",           # "Mechanisation"
    str_detect(name, "Belowground") ~ "Agronomy",         # "Belowground (crop-tree) competition" 
    str_detect(name, "Aboveground") ~ "Agronomy",         # "Aboveground (crop-tree) light competition" 
    str_detect(name, "Nutrient use") ~ "Agronomy",
    str_detect(name, "Nutrient use effeciency") ~ "Agronomy",
    str_detect(name, "Breeding and selection") ~ "Agronomy",
    # ---------------------------------------------------------------------------------------------------
    
    str_detect(name, "Breeding and selection") ~ "Environment",
    str_detect(name, "Soil quality") ~ "Environment",
    str_detect(name, "Biodiversity") ~ "Environment",
    str_detect(name, "Carbon stock") ~ "Environment",
    str_detect(name, "Greenhouse gas emissions") ~ "Environment",
    str_detect(name, "Pollination") ~ "Environment",
    str_detect(name, "Soil structure") ~ "Environment",
    str_detect(name, "Chemical soil components") ~ "Environment",
    str_detect(name, "Biological soil components") ~ "Environment",
    str_detect(name, "Soil water") ~ "Environment",
    str_detect(name, "Soil erosion") ~ "Environment",
    str_detect(name, "Soil formations") ~ "Environment",
    str_detect(name, "Water quality") ~ "Environment",
    str_detect(name, "Water perculation") ~ "Environment",
    str_detect(name, "Water cyclings") ~ "Environment",
    str_detect(name, "Water availability") ~ "Environment",
    str_detect(name, "Hydraulic lift") ~ "Environment",
    # ---------------------------------------------------------------------------------------------------
    
    str_detect(name, "Economic profit related") ~ "Economic",
    str_detect(name, "Economic management related") ~ "Economic",
    str_detect(name, "Economic market related") ~ "Economic",
    # ---------------------------------------------------------------------------------------------------
    
    str_detect(name, "Landscape aesthetics") ~ "Cultural",
    str_detect(name, "Recreational and ecotourism") ~ "Cultural",
    str_detect(name, "Spiritual values") ~ "Cultural",
    str_detect(name, "Perception of adoptation") ~ "Cultural",
    str_detect(name, "Policy information") ~ "Cultural"))
    

category.ecosystem.long
```

```{r}
# generating plot 
pub.year.plot <- 
  ggplot(data = pub.year.data) +
  geom_step(aes(x = yeardate, y = no_studies_accum, alpha = 0.9), size = 0.5, col = "black") +
 # geom_point(aes(x = yeardate, y = no_studies_accum,alpha = 0.85, size = 0.2), col = my_col_single) +
  geom_col(aes(x = yeardate, y = no_studies, alpha = 0.9), fill = my_col_single) +
  theme_bw() +
  scale_x_datetime(name = "Year", 
                         breaks = date_breaks("1 years"),
                         labels = date_format(format = "%Y"),
                         expand = c(0.1, 0.1)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")  +
  scale_y_continuous(breaks = pretty(pub.year.data$no_studies_accum, n = 20), minor_breaks = 1, limits = c(0, 80)) +
  labs(title = "Accumulated peer-reviewed publications over time",
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       y = "Accumulated number of publications") 
```

```{r}
  dplyr::filter(ES.INDICATORS != "NA") %>%   # excluding 41 records of 'NA'
  dplyr::filter(ES.INDICATORS != "ID.P" &
                  ES.INDICATORS != "Provisioning ES" & 
                  ES.INDICATORS != "Regulating ES" &
                  ES.INDICATORS != "Supporting ES" &
                  ES.INDICATORS != "Cultural ES" &
                  ES.INDICATORS != "Ecosystem Services") %>% # excluding ID.P recordings
  add_tally(wt = count) %>%
  mutate(pct = (count/n)) %>%
  
```

```{r}
matrix.es.bd.cat.systrait.crop.group.plot <- matrix.es.bd.cat.systrait.crop.all %>%
  
  group_by(CROP.OUTPUT.GROUP, `SAF System Trait type`) %>%
  summarise(count = n()) %>%
  ungroup() %>% 
  
  ggplot(aes(x = reorder(CROP.OUTPUT.GROUP, -count), 
             y = count,
             fill = CROP.OUTPUT.GROUP)) +
  geom_point(aes(size = count), shape = 21, colour = "black",
             alpha = 0.8) +
  #scale_size_area(max_size = 20, guide = "none") +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none",
        plot.margin = margin(l = 0 + margin_spacer(matrix.es.bd.cat.systrait.crop.all$CROP.OUTPUT.GROUP))) +
  scale_size_continuous(range = c(-1, 10)) +
  scale_fill_discrete_qualitative(palette = "Dynamic") +
  facet_grid(`SAF System Trait type` ~ .) +
  labs(title = "Matrix showing the number of peer-reviewed papers reporting on different crop groups and indicators for different crop groups",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("n(independent studies) reporting on biodiversity-related indicators = ", total_n_BD$value),
       x = "Crop groups",                       
       y = "Biodiversity-related indicators")
  
matrix.es.bd.cat.systrait.crop.group.plot
```

```{r}
matrix.es.bd.cat.systrait.crop.group.plot <- matrix.es.bd.cat.systrait.crop.all %>%
  
  group_by(CROP.GENUS.GROUP, `SAF System Trait type`) %>%
  summarise(count = n()) %>%
  ungroup() %>% 
  
  ggplot(aes(x = reorder(CROP.GENUS.GROUP, -count), 
             y = count,
             fill = CROP.GENUS.GROUP)) +
  geom_point(aes(size = count), shape = 21, colour = "black",
             alpha = 0.8) +
  scale_size_area(max_size = 20, guide = "none") +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none",
        plot.margin = margin(l = 0 + margin_spacer(matrix.es.bd.cat.systrait.crop.all$CROP.GENUS.GROUP))) +
  scale_size_continuous(range = c(-1, 10)) +
  scale_fill_discrete_qualitative(palette = "Dynamic") +
  facet_grid(`SAF System Trait type` ~ .)

  labs(title = "Matrix showing the number of peer-reviewed papers reporting on biodiversity-related indicators for different crop groups",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("n(independent studies) reporting on biodiversity-related indicators = ", total_n_BD$value),
       x = "Crop groups",                       
       y = "Biodiversity-related indicators")

matrix.es.bd.cat.systrait.crop.group.plot
```

```{r}
plyr::mutate(MANAGEMENT = case_when(
      str_detect(MANAGEMENT, "CON") ~ "Con",
      str_detect(MANAGEMENT, "ORG") ~ "Org",
      str_detect(MANAGEMENT, "CON.ORG") ~ "Con + Org",
      str_detect(MANAGEMENT, "NA") ~ "No data",
      TRUE ~ as.character(as.character(MANAGEMENT)))) %>%
```

*Preparing ES, BD, CAT - crop datasets for matrix plot*
```{r Preparing the merged ES, BD, CAT - crop dataset}
matrix.es.bd.cat.systrait.crop <- 
  joined.es.bd.cat.systrait.crop %>%
  filter(CROP.OUTPUT.GROUP != "NA") %>%
  filter(!is.na(CROP.GENUS.GROUP))

matrix.es.bd.cat.systrait.crop.all <- 
  matrix.es.bd.cat.systrait.crop %>%
    dplyr::select(
    "SAF System Trait type",
    
    "Food (yield)",
    "Feed",
    "Fuel (firewood etc.)",
    "Biodiversity",
    "Disease regulation",
    "Pest regulation",
    "Water cycling",
    "Economic management related",
    "Economic profit related",
    "Aboveground (crop-tree) light competition",
    "Soil structure", 
    "Chemical soil components",
    "Biological soil components",
    "Land equivalent ratio",
    "Climate regulation",
    "Greenhouse gas emissions",
    "Carbon sequestration",
    
    "CROP.GENUS.GROUP",
    "CROP.OUTPUT.GROUP") %>%
  mutate_if(is.character, as.factor) %>%
  relocate(`SAF System Trait type`, CROP.GENUS.GROUP, CROP.OUTPUT.GROUP)
```

```{r}
matrix.es.bd.cat.systrait.crop.all %>%
  
  group_by(CROP.GENUS.GROUP, `SAF System Trait type`) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(pct = (count/sum(count))) %>%
  arrange(desc(count))
```

```{r}
joined.es.bd.cat.systrait.crop <- 
  left_join(x = joined.es.bd.cat.systrait.crop, y = system.traits.data.raw,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S")) %>%
  select(-(ends_with(".x") | ends_with(".y"))) %>%
  select(-ST.TYPE)
```

*Preparing data*
```{r}
#devtools::install_github("cardiomoon/webr")
# library(webr)
PD <- 
  database %>% 
  group_by(STUDY.FRAME, ST.TYPE) %>% 
  summarise(n = n())
```
```{r}
# Pie-Donut chart
webr::PieDonut(PD, aes(STUDY.FRAME, ST.TYPE, count = n), ratioByGroup = FALSE,
               title = "The Pie-Donut chart")
```

```{r}
  dplyr::group_by(`Food (yield)`, 
                  `Feed`,
                  `Fibre`,
                  `Fuel (firewood etc.)`,
                  `Genetic resources`,
                  `Biochemicals`,
                  `Ornamentals`,
                  `Fresh water`,
                  
                  `Air regulation`,
                  `Climate regulation`,
                  `Carbon sequestration`,
                  `Water regulation`,
                  `Erosion regulation`,
                  `Water purification`,
                  `Disease regulation`,
                  `Pest regulation`,
                  `Polination regulation`,
                  `Natural hazards regulation`,
                  
                  `Soil formation`,
                  `Photosynthesis`,
                  `Primary production`,
                  `Nutrient cycling`,
                  `Water cycling`,
     
                  `Cultural diversity`,
                  `Spiritual value`,
                  `Knowledge systems`,
                  `Educational value`,
                  `Inspirational value`,
                  `Aesthetic value`,
                  `Social relations`,
                  `Sense of place`,
                  `Cultural heritage value`,
                  `Recreational and ecotourism`) %>% 
  summarise(n = sum()) %>%
  ungroup()
```


Food (yield)
Feed
Fibre
Fuel (firewood etc.)
Genetic resources
Biochemicals
Ornamentals
Fresh water
       
Air regulation
Climate regulation
Carbon sequestration
Water regulation
Erosion regulation
Water purification
Disease regulation
Pest regulation
Polination regulation
Natural hazards regulation
       
Soil formation
Photosynthesis
Primary production
Nutrient cycling
Water cycling
     
Cultural diversity
Spiritual value
Knowledge systems
Educational value
Inspirational value
Aesthetic value
Social relations
Sense of place
Cultural heritage value
Recreational and ecotourism
         
Provisioning ES
Regulating ES
Supporting ES
Cultural ES
Ecosystem Services

```{r}
```{r}
#devtools::install_github("cardiomoon/webr")
# library(webr)
ES.TIER1 <- 
 ecosystem.data.renamed %>%
  dplyr::select(ID.P,
                `Provisioning ES`, `Regulating ES`, `Supporting ES`, `Cultural ES`) %>%
  pivot_longer(cols = !ID.P,
               names_to = "ES.TIER1.GROUP",
               values_to = "value") 

ES.TIER2 <- 
 ecosystem.data.renamed %>%
  dplyr::select(ID.P,
                !c(`Ecosystem Services`, `Provisioning ES`, `Regulating ES`, `Supporting ES`, `Cultural ES`)) %>%
  pivot_longer(cols = !ID.P,
               names_to = "ES.TIER2.GROUP",
               values_to = "value")
 
ES.TIER2
```

```{r}
ES.PD.data <- 
  left_join(x = ES.TIER1, y = ES.TIER2, 
            by = c("ID.P" = "ID.P"))  %>%
  select(-(ends_with(".x") | ends_with(".y"))) %>%
  relocate(ID.P) %>%
  group_by(ES.TIER1.GROUP, ES.TIER2.GROUP) %>%
  summarise(n_ES.GROUP = n())


  dplyr::group_by(ES.TIER1.GROUP, ES.TIER2.GROUP) %>%
  summarise(count = n()) %>%
  ungroup()

# Building a table with the data for the plot
ES.PD.data <- ES.PD.data %>% 
  dplyr::group_by(ES.TIER1.GROUP, ES.TIER2.GROUP) %>% 
  summarise(n = sum(count))
```

```{r}
spatial.scale.pos <- spatial.scale %>% 
  mutate(csum = rev(cumsum(rev(count))), 
         pos = count/2 + lead(csum, 1),
         pos = if_else(is.na(pos), count/3, pos)) %>%
  mutate(across(where(is.numeric), round, 3))

labels <- c(PLOT.FARM = "Plot and farm", var2 = "Custom Value 2", var3 = "Custom Value 3")

spatial.scale %>%
  ggplot(aes(x = "", y = count, fill = SCALE), alpha = 0.6) +
  geom_col(width = 1) +
  scale_fill_discrete_qualitative(palette = "Dynamic") +
  #geom_text(aes(label = count),
  #         position = position_stack(vjust = 0.5)) +
  coord_polar(theta = "y") +
  geom_label_repel(aes(y = spatial.scale.pos$pos, label = paste0(pct* 100, " %")),
                   size = 4.5, nudge_x = 1, show.legend = FALSE) +
 # guides(fill = guide_legend(title = "Group")) +
  scale_y_continuous(breaks = spatial.scale.pos$pos, labels = spatial.scale$SCALE) +
  theme_bw() +
  theme(axis.ticks = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(), #element_text(size = 15), 
        legend.position = "bottom", # Removes the legend
        panel.background = element_rect(fill = "white")) 
```

```{r}
temp.scale.pos <- temp.scale %>% 
  mutate(csum = rev(cumsum(rev(count))), 
         pos = count/2 + lead(csum, 1),
         pos = if_else(is.na(pos), count/3, pos)) %>%
  mutate(across(where(is.numeric), round, 3))

labels <- c(var1 = "Custom Value 1", var2 = "Custom Value 2", var3 = "Custom Value 3")

temp.scale %>%
  ggplot(aes(x = "", y = count, fill = DUR.SAMPLING), alpha = 0.6) +
  geom_col(width = 1) +
  scale_fill_discrete_qualitative(palette = "Dynamic") +
  #geom_text(aes(label = count),
  #         position = position_stack(vjust = 0.5)) +
  coord_polar(theta = "y") +
  geom_label_repel(aes(y = temp.scale.pos$pos, label = paste0(DUR.SAMPLING, "; ", pct* 100, " %")),
                   size = 4.5, nudge_x = 1, show.legend = FALSE) +
 # guides(fill = guide_legend(title = "Group")) +
  scale_y_continuous(breaks = temp.scale.pos$pos, labels = temp.scale$DUR.SAMPLING) +
  theme_bw() +
  theme(axis.ticks = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(), #element_text(size = 15), 
        legend.position = "none", # Removes the legend
        panel.background = element_rect(fill = "white")) 
```

```{r}
temporal.scale.PD.data %>%
ggplot(aes(x = 2, y = n, fill = Tier_1_scale)) +
  geom_col(alpha = 0.8) +
  coord_polar(theta = "y") +
  theme(panel.background = element_blank(),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        plot.title = element_text(hjust = 0.5, size = 12)) +
  ggtitle("Temporal scale used by studies") +
  #scale_fill_manual(values = colours) +
  xlim(c(0.2, 2 + 0.5)) 
```

Creating a function for plotting tree genera vs. soil variables


```{r}
fun.tree.genera.soil <- function(tree.soil.data, soil.variable){

trees.soil.data <- tree.soil.data
sandmean <- soil.variable

# ------------------------------------------------------------------------------------------------------   
# generating plot
trees.sand.violin.plot <- 
trees.soil.data %>%
  filter(TREE.FAMILY.GROUP != "NA") %>%
  filter(sandmean > 0) %>%
  group_by(TREE.FAMILY.GROUP) %>% 
  filter(n() >= 10) %>%

  ggplot(aes(y = sandmean, x = reorder(TREE.FAMILY.GROUP, sandmean))) +
  geom_violin(aes(fill = TREE.FAMILY.GROUP, alpha = 0.7)) +
  stat_summary(
    fun.data = "mean_sdl",  fun.args = list(mult = 1), 
    geom = "pointrange", color = "black"
    ) +
  geom_jitter(height = 5, width = 0.1,
              size = 1.1, aes(col = TREE.FAMILY.GROUP, alpha = 0.8)) +
  theme_bw() +
  ylim(0, 50) +
  theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none") +
  scale_colour_discrete_qualitative(palette = "Dynamic") +
  labs(title = "Distribution of tree genera across soil sand content gradients",
       subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
       caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Tree genera",
       y = "Soil sand content [%]") +
  coord_flip()
  

trees.sand.violin.plot

# ------------------------------------------------------------------------------------------------------ 
# printing the output of the function (essentially the plot)

return(trees.sand.violin.plot)
  
}
```

Testing function
```{r}
fun.tree.genera.soil(tree.soil.data = trees.soil.data, 
                     soil.variable = "bdodmean")
```

Europe map
```{r}
# We can now plot the map with the specified display window for zoom level 2, highlighting the zoom center for Europe
sample <- data.frame(Longitude=c(-1+rnorm(50,0,.5),-2+rnorm(50,0,0.5),-4.5+rnorm(50,0,.5)),
                     Latitude =c(52+rnorm(50,0,.5),54+rnorm(50,0,0.5),56+rnorm(50,0,.5)))
UKmap  <- readOGR(dsn = ".", layer = "GBR_adm1")
map.df <- fortify(worldmap)

database.lat.lon %>%
ggplot(aes(x = longitude, y = latitude)) + 
  stat_density2d(aes(fill = ..level..), alpha = 0.5, geom = "polygon") +
  geom_point(colour = "red") +
  geom_sf(data = worldmap) +
  scale_fill_gradientn(colours = rev(brewer.pal(7, "Spectral")))+
  xlim(-10, +2.5) +
  coord_fixed()


ggplot() + geom_sf(data = worldmap) +
    geom_sf(data = st_sfc(st_point(zoom_to.eu), crs = 4326),
            color = 'blue', alpha = 0) +
  
    coord_sf(xlim = lon_bounds.eu, ylim = lat_bounds.eu) + theme_bw() +
    geom_point(
    data = database.lat.lon,
    aes(longitude, latitude, color = ST.TYPE),
    alpha = 0.7, size = 0.8
  ) +
  scale_x_continuous(label = abs) +
    scale_y_continuous(label = abs) +
    theme_bw() +
   theme(axis.text.x = element_text(angle = 0, hjust = 1), legend.position = "none",
         plot.margin = margin(t = 0, r = 58, b = 0, l = 0, unit = "pt")) +
    labs(#title = "Locations of study sites for peer-reviewed silvoarable agroforestry",
      # subtitle = paste("n (individual study sites) = ", n_individual_study_sites),
      # caption = paste0("Total number of independent studies = ", n_independent_studies),
       x = "Longitude",
       y = "Latitude") 
  #labs(title = "Locations of study sites in Europe")

map.europe
```

```{r}
*Merging categorised biophys data with the general database*
Merging categorised biophys with the the general database where we find BD and ES information
```{r Merging categorised biophys data with the database}

biophys.categorised.database <- 
  left_join(biophys.categorised, database.lat.lon,
            by = c("ID.P" = "ID.P",
                   "ID.S" = "ID.S"))
```
```

